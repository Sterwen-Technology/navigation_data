#   Python code generated by NMEA message router application (c) Sterwen Technology 2023
#   generated on 2023-52-23:17:52
#   do not modify code


import struct

from nmea2000.generated_base import *
from generated.nmea2000_pb2 import nmea2000_decoded_pb

from generated.nmea2000_classes_gen_pb2 import *


class Pgn65359Mfg1851Class(NMEA2000DecodedMsg):

    _pgn = 65359
    _name = 'Raymarine: Pilot heading'
    _proprietary = True
    _manufacturer_id = 1851
    _struct_str_0 = struct.Struct('<HBHH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_true_heading', '_magnetic_heading')

    _static_size = 7

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def true_heading(self) -> float:
        return self._true_heading

    @property
    def magnetic_heading(self) -> float:
        return self._magnetic_heading

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[1]
        self._true_heading = check_convert_float(val[2], 0xffff, 0.005729577951308233)
        self._magnetic_heading = check_convert_float(val[3], 0xffff, 0.005729577951308233)
        return self

    def from_protobuf(self, message: Pgn65359Mfg1851ClassPb):
        self._system_id = message.system_id
        self._true_heading = message.true_heading
        self._magnetic_heading = message.magnetic_heading

    def as_protobuf(self) -> Pgn65359Mfg1851ClassPb:
        message = Pgn65359Mfg1851ClassPb()
        message.system_id = self._system_id
        message.true_heading = self._true_heading
        message.magnetic_heading = self._magnetic_heading
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn65359Mfg1851ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, true_heading={self._true_heading}, magnetic_heading={self._magnetic_heading}]'


class Pgn65379Mfg1851Class(NMEA2000DecodedMsg):

    _pgn = 65379
    _name = 'Raymarine: Pilot mode'
    _proprietary = True
    _manufacturer_id = 1851
    _struct_str_0 = struct.Struct('<HBBBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_pilot_mode', '_sub_mode', '_pilot_mode_data')

    _static_size = 6

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def pilot_mode(self) -> int:
        return self._pilot_mode

    @property
    def sub_mode(self) -> int:
        return self._sub_mode

    @property
    def pilot_mode_data(self) -> int:
        return self._pilot_mode_data

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[1]
        self._pilot_mode = val[2]
        self._sub_mode = val[3]
        self._pilot_mode_data = val[4]
        return self

    def from_protobuf(self, message: Pgn65379Mfg1851ClassPb):
        self._system_id = message.system_id
        self._pilot_mode = message.pilot_mode
        self._sub_mode = message.sub_mode
        self._pilot_mode_data = message.pilot_mode_data

    def as_protobuf(self) -> Pgn65379Mfg1851ClassPb:
        message = Pgn65379Mfg1851ClassPb()
        message.system_id = self._system_id
        message.pilot_mode = self._pilot_mode
        message.sub_mode = self._sub_mode
        message.pilot_mode_data = self._pilot_mode_data
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn65379Mfg1851ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, pilot_mode={self._pilot_mode}, sub_mode={self._sub_mode}, pilot_mode_data={self._pilot_mode_data}]'


class Pgn126992Class(NMEA2000DecodedMsg):

    _pgn = 126992
    _name = 'System Time'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBHI')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_source', '_date', '_time')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _source_enum = {
        0: 'GPS',
        1: 'GLONASS',
        2: 'Radio Station',
        3: 'Local Cesium clock',
        4: 'Local Rubidium clock',
        5: 'Local Crystal clock'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def source(self) -> int:
        return self._source

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @property
    def source_text(self) -> str:
        return self._source_enum.get(self._source, 'source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._source = (val[1] >> 4) & 0xF
        self._date = val[2]
        self._time = check_convert_float(val[3], 0xffffffff, 0.0001)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0xf << 0
        v0 |= (self._source & 0xf) << 4
        v1 = int(self._time / 0.0001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, self._date, v1)
        return buffer

    def from_protobuf(self, message: Pgn126992ClassPb):
        self._system_id = message.system_id
        self._source = message.source
        self._date = message.date
        self._time = message.time

    def as_protobuf(self) -> Pgn126992ClassPb:
        message = Pgn126992ClassPb()
        message.system_id = self._system_id
        message.source = self._source
        message.date = self._date
        message.time = self._time
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126992ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, source={self._source}, date={self._date}, time={self._time}]'


class Pgn126993Class(NMEA2000DecodedMsg):

    _pgn = 126993
    _name = 'Heartbeat'
    _proprietary = False
    _struct_str_0 = struct.Struct('<HBBI')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_interval', '_status')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def interval(self) -> float:
        return self._interval

    @property
    def status(self) -> int:
        return self._status

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._interval = check_convert_float(val[0], 0xffff, 10.0)
        self._status = val[1]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._interval / 10.0)
        v1 = 0xff
        v2 = 0xffffffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._status, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn126993ClassPb):
        self._interval = message.interval
        self._status = message.status

    def as_protobuf(self) -> Pgn126993ClassPb:
        message = Pgn126993ClassPb()
        message.interval = self._interval
        message.status = self._status
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126993ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [interval={self._interval}, status={self._status}]'


class Pgn126996Class(NMEA2000DecodedMsg):

    _pgn = 126996
    _name = 'Product Information'
    _proprietary = False
    _struct_str_0 = struct.Struct('<HH')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<BB')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_nmea2000_version', '_product_code', '_product_information', '_certification_level', '_load_equivalency')

    _static_size = 134

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def nmea2000_version(self) -> int:
        return self._nmea2000_version

    @property
    def product_code(self) -> int:
        return self._product_code

    @property
    def product_information(self) -> str:
        return self._product_information

    @property
    def certification_level(self) -> int:
        return self._certification_level

    @property
    def load_equivalency(self) -> int:
        return self._load_equivalency

    @nmea2000_version.setter
    def nmea2000_version(self, value: int):
        self._nmea2000_version = value

    @product_code.setter
    def product_code(self, value: int):
        self._product_code = value

    @product_information.setter
    def product_information(self, value: str):
        self._product_information = value

    @certification_level.setter
    def certification_level(self, value: int):
        self._certification_level = value

    @load_equivalency.setter
    def load_equivalency(self, value: int):
        self._load_equivalency = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._nmea2000_version = val[0]
        self._product_code = val[1]
        self._product_information = clean_string(payload[4 + start_byte: 132 + start_byte])
        val = self._struct_str_1.unpack_from(payload, 132 + start_byte)
        self._certification_level = val[0]
        self._load_equivalency = val[1]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._nmea2000_version, self._product_code)
        insert_string(buffer, 4 + start_byte, 128, self._product_information)
        self._struct_str_1.pack_into(buffer, 132 + start_byte, self._certification_level, self._load_equivalency)
        return buffer

    def from_protobuf(self, message: Pgn126996ClassPb):
        self._nmea2000_version = message.nmea2000_version
        self._product_code = message.product_code
        self._product_information = message.product_information
        self._certification_level = message.certification_level
        self._load_equivalency = message.load_equivalency

    def as_protobuf(self) -> Pgn126996ClassPb:
        message = Pgn126996ClassPb()
        message.nmea2000_version = self._nmea2000_version
        message.product_code = self._product_code
        message.product_information = self._product_information
        message.certification_level = self._certification_level
        message.load_equivalency = self._load_equivalency
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126996ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [nmea2000_version={self._nmea2000_version}, product_code={self._product_code}, product_information={self._product_information}, certification_level={self._certification_level}, load_equivalency={self._load_equivalency}]'


class Pgn127245Class(NMEA2000DecodedMsg):

    _pgn = 127245
    _name = 'Rudder'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBhhH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_instance', '_direction', '_angle', '_position')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _direction_enum = {
        0: 'No direction order',
        1: 'Move to starboard',
        2: 'Move to port',
        7: 'Unavailable'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def instance(self) -> int:
        return self._instance

    @property
    def direction(self) -> int:
        return self._direction

    @property
    def angle(self) -> float:
        return self._angle

    @property
    def position(self) -> float:
        return self._position

    @property
    def direction_text(self) -> str:
        return self._direction_enum.get(self._direction, 'direction key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._instance = val[0]
        self._direction = (val[1] >> 5) & 0x7
        self._angle = check_convert_float(val[2], 0x7fff, 0.005729577951308233)
        self._position = check_convert_float(val[3], 0x7fff, 0.005729577951308233)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = 0x1f << 0
        v0 |= (self._direction & 0x7) << 5
        v1 = int(self._angle / 0.005729577951308233)
        v2 = int(self._position / 0.005729577951308233)
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._instance, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127245ClassPb):
        self._instance = message.instance
        self._direction = message.direction
        self._angle = message.angle
        self._position = message.position

    def as_protobuf(self) -> Pgn127245ClassPb:
        message = Pgn127245ClassPb()
        message.instance = self._instance
        message.direction = self._direction
        message.angle = self._angle
        message.position = self._position
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127245ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [instance={self._instance}, direction={self._direction}, angle={self._angle}, position={self._position}]'


class Pgn127250Class(NMEA2000DecodedMsg):

    _pgn = 127250
    _name = 'Vessel Heading'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHhhB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_heading', '_deviation', '_variation', '_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _reference_enum = {
        0: 'True',
        1: 'Magnetic'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def deviation(self) -> float:
        return self._deviation

    @property
    def variation(self) -> float:
        return self._variation

    @property
    def reference(self) -> int:
        return self._reference

    @property
    def reference_text(self) -> str:
        return self._reference_enum.get(self._reference, 'reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._heading = check_convert_float(val[1], 0xffff, 0.005729577951308233)
        self._deviation = check_convert_float(val[2], 0x7fff, 0.005729577951308233)
        self._variation = check_convert_float(val[3], 0x7fff, 0.005729577951308233)
        self._reference = val[4] & 0x3
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._heading / 0.005729577951308233)
        v1 = int(self._deviation / 0.005729577951308233)
        v2 = int(self._variation / 0.005729577951308233)
        v3 = (self._reference & 0x3) << 0
        v3 |= 0x3f << 2
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127250ClassPb):
        self._system_id = message.system_id
        self._heading = message.heading
        self._deviation = message.deviation
        self._variation = message.variation
        self._reference = message.reference

    def as_protobuf(self) -> Pgn127250ClassPb:
        message = Pgn127250ClassPb()
        message.system_id = self._system_id
        message.heading = self._heading
        message.deviation = self._deviation
        message.variation = self._variation
        message.reference = self._reference
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127250ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, heading={self._heading}, deviation={self._deviation}, variation={self._variation}, reference={self._reference}]'


class Pgn127488Class(NMEA2000DecodedMsg):

    _pgn = 127488
    _name = 'Engine Parameters, Rapid Update'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHHbH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_engine_instance', '_engine_speed')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def engine_instance(self) -> int:
        return self._engine_instance

    @property
    def engine_speed(self) -> float:
        return self._engine_speed

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._engine_instance = val[0]
        self._engine_speed = check_convert_float(val[1], 0xffff, 0.25)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._engine_speed / 0.25)
        v1 = 0xffff
        v2 = 0xff
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._engine_instance, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn127488ClassPb):
        self._engine_instance = message.engine_instance
        self._engine_speed = message.engine_speed

    def as_protobuf(self) -> Pgn127488ClassPb:
        message = Pgn127488ClassPb()
        message.engine_instance = self._engine_instance
        message.engine_speed = self._engine_speed
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127488ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [engine_instance={self._engine_instance}, engine_speed={self._engine_speed}]'


class Pgn127489Class(NMEA2000DecodedMsg):

    _pgn = 127489
    _name = 'Engine Parameters, Dynamic'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHHHhhIHHBhhbb')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_engine_instance', '_oil_pressure', '_oil_temperature', '_temperature', '_alternator_voltage', '_fuel_rate', '_total_engine_hours')

    _static_size = 26

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def engine_instance(self) -> int:
        return self._engine_instance

    @property
    def oil_pressure(self) -> int:
        return self._oil_pressure

    @property
    def oil_temperature(self) -> float:
        return self._oil_temperature

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def alternator_voltage(self) -> float:
        return self._alternator_voltage

    @property
    def fuel_rate(self) -> float:
        return self._fuel_rate

    @property
    def total_engine_hours(self) -> float:
        return self._total_engine_hours

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._engine_instance = val[0]
        self._oil_pressure = check_convert_float(val[1], 0xffff, 100.0)
        self._oil_temperature = check_convert_float(val[2], 0xffff, 0.1, -273.15)
        self._temperature = check_convert_float(val[3], 0xffff, 0.01, -273.15)
        self._alternator_voltage = check_convert_float(val[4], 0x7fff, 0.01)
        self._fuel_rate = check_convert_float(val[5], 0x7fff, 0.1)
        self._total_engine_hours = check_convert_float(val[6], 0xffffffff, 0.00027777778)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int((self._oil_temperature - -273.15) / 0.1)
        v1 = int((self._temperature - -273.15) / 0.01)
        v2 = int(self._alternator_voltage / 0.01)
        v3 = int(self._fuel_rate / 0.1)
        v4 = int(self._total_engine_hours / 0.00027777778)
        v5 = 0xffff
        v6 = 0xffff
        v7 = 0xff
        v8 = 0xffff
        v9 = 0xffff
        v10 = 0xff
        v11 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._engine_instance, self._oil_pressure, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
        return buffer

    def from_protobuf(self, message: Pgn127489ClassPb):
        self._engine_instance = message.engine_instance
        self._oil_pressure = message.oil_pressure
        self._oil_temperature = message.oil_temperature
        self._temperature = message.temperature
        self._alternator_voltage = message.alternator_voltage
        self._fuel_rate = message.fuel_rate
        self._total_engine_hours = message.total_engine_hours

    def as_protobuf(self) -> Pgn127489ClassPb:
        message = Pgn127489ClassPb()
        message.engine_instance = self._engine_instance
        message.oil_pressure = self._oil_pressure
        message.oil_temperature = self._oil_temperature
        message.temperature = self._temperature
        message.alternator_voltage = self._alternator_voltage
        message.fuel_rate = self._fuel_rate
        message.total_engine_hours = self._total_engine_hours
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127489ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [engine_instance={self._engine_instance}, oil_pressure={self._oil_pressure}, oil_temperature={self._oil_temperature}, temperature={self._temperature}, alternator_voltage={self._alternator_voltage}, fuel_rate={self._fuel_rate}, total_engine_hours={self._total_engine_hours}]'


class Pgn127508Class(NMEA2000DecodedMsg):

    _pgn = 127508
    _name = 'Battery Status'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BhhHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_battery_instance', '_voltage', '_current', '_temperature', '_system_id')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def battery_instance(self) -> int:
        return self._battery_instance

    @property
    def voltage(self) -> float:
        return self._voltage

    @property
    def current(self) -> float:
        return self._current

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def system_id(self) -> int:
        return self._system_id

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._battery_instance = val[0]
        self._voltage = check_convert_float(val[1], 0x7fff, 0.01)
        self._current = check_convert_float(val[2], 0x7fff, 0.1)
        self._temperature = check_convert_float(val[3], 0xffff, 0.01, -273.15)
        self._system_id = val[4]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._voltage / 0.01)
        v1 = int(self._current / 0.1)
        v2 = int((self._temperature - -273.15) / 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._battery_instance, v0, v1, v2, self._system_id)
        return buffer

    def from_protobuf(self, message: Pgn127508ClassPb):
        self._battery_instance = message.battery_instance
        self._voltage = message.voltage
        self._current = message.current
        self._temperature = message.temperature
        self._system_id = message.system_id

    def as_protobuf(self) -> Pgn127508ClassPb:
        message = Pgn127508ClassPb()
        message.battery_instance = self._battery_instance
        message.voltage = self._voltage
        message.current = self._current
        message.temperature = self._temperature
        message.system_id = self._system_id
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn127508ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [battery_instance={self._battery_instance}, voltage={self._voltage}, current={self._current}, temperature={self._temperature}, system_id={self._system_id}]'


class Pgn128259Class(NMEA2000DecodedMsg):

    _pgn = 128259
    _name = 'Speed'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BhhBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_speed_through_water', '_speed_over_ground_ref', '_speed_through_water_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _speed_through_water_reference_enum = {
        0: 'Paddle wheel',
        1: 'Pitot tube',
        2: 'Doppler log',
        3: 'Correlation log (Ultra-Sound)',
        4: 'EM log (Electro-Magnetic)'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def speed_through_water(self) -> float:
        return self._speed_through_water

    @property
    def speed_over_ground_ref(self) -> float:
        return self._speed_over_ground_ref

    @property
    def speed_through_water_reference(self) -> int:
        return self._speed_through_water_reference

    @property
    def speed_through_water_reference_text(self) -> str:
        return self._speed_through_water_reference_enum.get(self._speed_through_water_reference, 'speed_through_water_reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._speed_through_water = check_convert_float(val[1], 0x7fff, 0.01)
        self._speed_over_ground_ref = check_convert_float(val[2], 0x7fff, 0.01)
        self._speed_through_water_reference = val[3]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._speed_through_water / 0.01)
        v1 = int(self._speed_over_ground_ref / 0.01)
        v2 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, self._speed_through_water_reference, v2)
        return buffer

    def from_protobuf(self, message: Pgn128259ClassPb):
        self._system_id = message.system_id
        self._speed_through_water = message.speed_through_water
        self._speed_over_ground_ref = message.speed_over_ground_ref
        self._speed_through_water_reference = message.speed_through_water_reference

    def as_protobuf(self) -> Pgn128259ClassPb:
        message = Pgn128259ClassPb()
        message.system_id = self._system_id
        message.speed_through_water = self._speed_through_water
        message.speed_over_ground_ref = self._speed_over_ground_ref
        message.speed_through_water_reference = self._speed_through_water_reference
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn128259ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, speed_through_water={self._speed_through_water}, speed_over_ground_ref={self._speed_over_ground_ref}, speed_through_water_reference={self._speed_through_water_reference}]'


class Pgn128267Class(NMEA2000DecodedMsg):

    _pgn = 128267
    _name = 'Water Depth'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BIhb')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_depth', '_offset', '_range')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def depth(self) -> float:
        return self._depth

    @property
    def offset(self) -> float:
        return self._offset

    @property
    def range(self) -> float:
        return self._range

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._depth = check_convert_float(val[1], 0xffffffff, 0.01)
        self._offset = check_convert_float(val[2], 0x7fff, 0.001)
        self._range = check_convert_float(val[3], 0x7f, 10.0)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._depth / 0.01)
        v1 = int(self._offset / 0.001)
        v2 = int(self._range / 10.0)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn128267ClassPb):
        self._system_id = message.system_id
        self._depth = message.depth
        self._offset = message.offset
        self._range = message.range

    def as_protobuf(self) -> Pgn128267ClassPb:
        message = Pgn128267ClassPb()
        message.system_id = self._system_id
        message.depth = self._depth
        message.offset = self._offset
        message.range = self._range
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn128267ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, depth={self._depth}, offset={self._offset}, range={self._range}]'


class Pgn129025Class(NMEA2000DecodedMsg):

    _pgn = 129025
    _name = 'Position, Rapid Update'
    _proprietary = False
    _struct_str_0 = struct.Struct('<ii')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_latitude', '_longitude')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def longitude(self) -> float:
        return self._longitude

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._latitude = check_convert_float(val[0], 0x7fffffff, 1e-07)
        self._longitude = check_convert_float(val[1], 0x7fffffff, 1e-07)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._latitude / 1e-07)
        v1 = int(self._longitude / 1e-07)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129025ClassPb):
        self._latitude = message.latitude
        self._longitude = message.longitude

    def as_protobuf(self) -> Pgn129025ClassPb:
        message = Pgn129025ClassPb()
        message.latitude = self._latitude
        message.longitude = self._longitude
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129025ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [latitude={self._latitude}, longitude={self._longitude}]'


class Pgn129026Class(NMEA2000DecodedMsg):

    _pgn = 129026
    _name = 'COG & SOG, Rapid Update'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBHHH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_COG_reference', '_COG', '_SOG')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _COG_reference_enum = {
        0: 'True',
        1: 'Magnetic'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def COG_reference(self) -> int:
        return self._COG_reference

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @property
    def COG_reference_text(self) -> str:
        return self._COG_reference_enum.get(self._COG_reference, 'COG_reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._COG_reference = val[1] & 0x3
        self._COG = check_convert_float(val[2], 0xffff, 0.005729577951308233)
        self._SOG = check_convert_float(val[3], 0xffff, 0.01)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._COG_reference & 0x3) << 0
        v0 |= 0x3f << 2
        v1 = int(self._COG / 0.005729577951308233)
        v2 = int(self._SOG / 0.01)
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn129026ClassPb):
        self._system_id = message.system_id
        self._COG_reference = message.COG_reference
        self._COG = message.COG
        self._SOG = message.SOG

    def as_protobuf(self) -> Pgn129026ClassPb:
        message = Pgn129026ClassPb()
        message.system_id = self._system_id
        message.COG_reference = self._COG_reference
        message.COG = self._COG
        message.SOG = self._SOG
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129026ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, COG_reference={self._COG_reference}, COG={self._COG}, SOG={self._SOG}]'


class Pgn129029Class(NMEA2000DecodedMsg):

    class Ref_StationsClass:

        _struct_str_0 = struct.Struct('<Bh')
        _struct_str_0_size = _struct_str_0.size
        __slots__ = ('_station_id', '_GNSS_type', '_age_DGNSS_correction')

        _static_size = 3

        @classmethod
        def size(cls):
            return cls._static_size

        @staticmethod
        def variable_size() -> bool:
            return False


        _GNSS_type_enum = 'GNSS type'

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def station_id(self) -> int:
            return self._station_id

        @property
        def GNSS_type(self) -> int:
            return self._GNSS_type

        @property
        def age_DGNSS_correction(self) -> float:
            return self._age_DGNSS_correction

        @property
        def GNSS_type_text(self) -> str:
            return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
            self._station_id = val[0] & 0xF
            self._GNSS_type = (val[0] >> 4) & 0xF
            self._age_DGNSS_correction = check_convert_float(val[1], 0x7fff, 0.01)
            return self

        def encode_payload(self, buffer, start_byte):
            v0 = (self._station_id & 0xf) << 0
            v0 |= (self._GNSS_type & 0xf) << 4
            v1 = int(self._age_DGNSS_correction / 0.01)
            self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1)

        def from_protobuf(self, message: Pgn129029ClassPb.Ref_StationsClassPb):
            self._station_id = message.station_id
            self._GNSS_type = message.GNSS_type
            self._age_DGNSS_correction = message.age_DGNSS_correction

        def as_protobuf(self) -> Pgn129029ClassPb.Ref_StationsClassPb:
            message = Pgn129029ClassPb.Ref_StationsClassPb()
            message.station_id = self._station_id
            message.GNSS_type = self._GNSS_type
            message.age_DGNSS_correction = self._age_DGNSS_correction
            return message

        def __str__(self):
            return f'(Ref_StationsClass) [station_id={self._station_id}, GNSS_type={self._GNSS_type}, age_DGNSS_correction={self._age_DGNSS_correction}]'


    _pgn = 129029
    _name = 'GNSS Position Data'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHIqqqBBBhhiB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_date', '_time', '_latitude', '_longitude', '_altitude', '_method', '_GNSS_type', '_integrity', '_number_of_sv', '_HDOP', '_PDOP', '_geoidal_separation', '_nb_ref_stations', '_ref_stations')

    _static_size = 43

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _GNSS_type_enum = 'GNSS type'
    _integrity_enum = {
        0: 'No integrity checking',
        1: 'Safe',
        2: 'Caution'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def altitude(self) -> float:
        return self._altitude

    @property
    def method(self) -> int:
        return self._method

    @property
    def GNSS_type(self) -> int:
        return self._GNSS_type

    @property
    def integrity(self) -> int:
        return self._integrity

    @property
    def number_of_sv(self) -> int:
        return self._number_of_sv

    @property
    def HDOP(self) -> float:
        return self._HDOP

    @property
    def PDOP(self) -> float:
        return self._PDOP

    @property
    def geoidal_separation(self) -> float:
        return self._geoidal_separation

    @property
    def nb_ref_stations(self) -> int:
        return self._nb_ref_stations

    @property
    def ref_stations(self) -> list:
        return self._ref_stations

    @property
    def GNSS_type_text(self) -> str:
        return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

    @property
    def integrity_text(self) -> str:
        return self._integrity_enum.get(self._integrity, 'integrity key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._date = val[1]
        self._time = check_convert_float(val[2], 0xffffffff, 0.0001)
        self._latitude = check_convert_float(val[3], 0x7fffffffffffffff, 1e-16)
        self._longitude = check_convert_float(val[4], 0x7fffffffffffffff, 1e-16)
        self._altitude = check_convert_float(val[5], 0x7fffffffffffffff, 1e-06)
        self._method = val[6] & 0xF
        self._GNSS_type = (val[6] >> 4) & 0xF
        self._integrity = val[7] & 0x3
        self._number_of_sv = val[8]
        self._HDOP = check_convert_float(val[9], 0x7fff, 0.01)
        self._PDOP = check_convert_float(val[10], 0x7fff, 0.01)
        self._geoidal_separation = check_convert_float(val[11], 0x7fffffff, 0.01)
        self._nb_ref_stations = check_valid(val[12], 255, 0)
        start_byte = self._static_size
        self._ref_stations = []
        for i in range(0, self.nb_ref_stations):
            self._ref_stations.append(self.Ref_StationsClass().decode_payload(payload, start_byte))
            start_byte += self.Ref_StationsClass.size()
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._time / 0.0001)
        v1 = int(self._latitude / 1e-16)
        v2 = int(self._longitude / 1e-16)
        v3 = int(self._altitude / 1e-06)
        v4 = (self._method & 0xf) << 0
        v4 |= (self._GNSS_type & 0xf) << 4
        v5 = (self._integrity & 0x3) << 0
        v5 |= 0x3f << 2
        v6 = int(self._HDOP / 0.01)
        v7 = int(self._PDOP / 0.01)
        v8 = int(self._geoidal_separation / 0.01)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, self._date, v0, v1, v2, v3, v4, v5, self._number_of_sv, v6, v7, v8, self._nb_ref_stations)
        for repeat_field in self._ref_stations:
            repeat_field.encode_payload(buffer, start_byte)
            start_byte += self.Ref_StationsClass.size()
        return buffer

    def from_protobuf(self, message: Pgn129029ClassPb):
        self._system_id = message.system_id
        self._date = message.date
        self._time = message.time
        self._latitude = message.latitude
        self._longitude = message.longitude
        self._altitude = message.altitude
        self._method = message.method
        self._GNSS_type = message.GNSS_type
        self._integrity = message.integrity
        self._number_of_sv = message.number_of_sv
        self._HDOP = message.HDOP
        self._PDOP = message.PDOP
        self._geoidal_separation = message.geoidal_separation
        self._nb_ref_stations = message.nb_ref_stations
        self._ref_stations = []
        for sub_set in message.ref_stations:
            self._ref_stations.append(self.Ref_StationsClass(protobuf=sub_set))

    def as_protobuf(self) -> Pgn129029ClassPb:
        message = Pgn129029ClassPb()
        message.system_id = self._system_id
        message.date = self._date
        message.time = self._time
        message.latitude = self._latitude
        message.longitude = self._longitude
        message.altitude = self._altitude
        message.method = self._method
        message.GNSS_type = self._GNSS_type
        message.integrity = self._integrity
        message.number_of_sv = self._number_of_sv
        message.HDOP = self._HDOP
        message.PDOP = self._PDOP
        message.geoidal_separation = self._geoidal_separation
        message.nb_ref_stations = self._nb_ref_stations
        for sub_set in self._ref_stations:
            message.ref_stations.append(sub_set.as_protobuf())
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129029ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, date={self._date}, time={self._time}, latitude={self._latitude}, longitude={self._longitude}, altitude={self._altitude}, method={self._method}, GNSS_type={self._GNSS_type}, integrity={self._integrity}, number_of_sv={self._number_of_sv}, HDOP={self._HDOP}, PDOP={self._PDOP}, geoidal_separation={self._geoidal_separation}, nb_ref_stations={self._nb_ref_stations}, ref_stations={self._ref_stations}]'


class Pgn129038Class(NMEA2000DecodedMsg):

    _pgn = 129038
    _name = 'AIS Class A Position Report'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BiiiBHHHBHHBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_longitude', '_latitude', '_position_accuracy', '_RAIM', '_timestamp', '_COG', '_SOG', '_communication_state', '_transceiver_information', '_heading', '_rate_of_turn', '_navigation_status')

    _static_size = 27

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }
    _timestamp_enum = {
        60: 'Not available',
        61: 'Manual input mode',
        62: 'Dead reckoning mode',
        63: 'Positioning system is inoperative'
        }
    _transceiver_information_enum = {
        0: 'Channel A VDL reception',
        1: 'Channel B VDL reception',
        2: 'Channel A VDL transmission',
        3: 'Channel B VDL transmission',
        4: 'Own information not broadcast',
        5: 'Reserved'
        }
    _navigation_status_enum = {
        0: 'Under way using engine',
        1: 'At anchor',
        2: 'Not under command',
        3: 'Restricted manoeuverability',
        4: 'Constrained by her draught',
        5: 'Moored',
        6: 'Aground',
        7: 'Engaged in Fishing',
        8: 'Under way sailing'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def position_accuracy(self) -> int:
        return self._position_accuracy

    @property
    def RAIM(self) -> int:
        return self._RAIM

    @property
    def timestamp(self) -> int:
        return self._timestamp

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @property
    def communication_state(self) -> int:
        return self._communication_state

    @property
    def transceiver_information(self) -> int:
        return self._transceiver_information

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def rate_of_turn(self) -> float:
        return self._rate_of_turn

    @property
    def navigation_status(self) -> int:
        return self._navigation_status

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    @property
    def timestamp_text(self) -> str:
        return self._timestamp_enum.get(self._timestamp, 'timestamp key error')

    @property
    def transceiver_information_text(self) -> str:
        return self._transceiver_information_enum.get(self._transceiver_information, 'transceiver_information key error')

    @property
    def navigation_status_text(self) -> str:
        return self._navigation_status_enum.get(self._navigation_status, 'navigation_status key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._longitude = check_convert_float(val[2], 0x7fffffff, 1e-07)
        self._latitude = check_convert_float(val[3], 0x7fffffff, 1e-07)
        self._position_accuracy = val[4] & 0x1
        self._RAIM = (val[4] >> 1) & 0x1
        self._timestamp = (val[4] >> 2) & 0x3F
        self._COG = check_convert_float(val[5], 0xffff, 0.005729577951308233)
        self._SOG = check_convert_float(val[6], 0xffff, 0.01)
        word = val[7] + (val[8] << 16)
        self._communication_state = word & 0x7FFFF
        word = val[7] + (val[8] << 16)
        self._transceiver_information = (word >> 19) & 0x1F
        self._heading = check_convert_float(val[9], 0xffff, 0.005729577951308233)
        self._rate_of_turn = check_convert_float(val[10], 0xffff, 0.005729577951308233)
        self._navigation_status = val[11]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        v1 = int(self._longitude / 1e-07)
        v2 = int(self._latitude / 1e-07)
        v3 = (self._position_accuracy & 0x1) << 0
        v3 |= (self._RAIM & 0x1) << 1
        v3 |= (self._timestamp & 0x3f) << 2
        v4 = int(self._COG / 0.005729577951308233)
        v5 = int(self._SOG / 0.01)
        v6 = (self._communication_state & 0x7ffff) << 0
        v6 |= (self._transceiver_information & 0x1f) << 19
        v7 = int(self._heading / 0.005729577951308233)
        v8 = int(self._rate_of_turn / 0.005729577951308233)
        v9 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, v1, v2, v3, v4, v5, v6, v7, v8, self._navigation_status, v9)
        return buffer

    def from_protobuf(self, message: Pgn129038ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._longitude = message.longitude
        self._latitude = message.latitude
        self._position_accuracy = message.position_accuracy
        self._RAIM = message.RAIM
        self._timestamp = message.timestamp
        self._COG = message.COG
        self._SOG = message.SOG
        self._communication_state = message.communication_state
        self._transceiver_information = message.transceiver_information
        self._heading = message.heading
        self._rate_of_turn = message.rate_of_turn
        self._navigation_status = message.navigation_status

    def as_protobuf(self) -> Pgn129038ClassPb:
        message = Pgn129038ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.timestamp = self._timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_information = self._transceiver_information
        message.heading = self._heading
        message.rate_of_turn = self._rate_of_turn
        message.navigation_status = self._navigation_status
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129038ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, longitude={self._longitude}, latitude={self._latitude}, position_accuracy={self._position_accuracy}, RAIM={self._RAIM}, timestamp={self._timestamp}, COG={self._COG}, SOG={self._SOG}, communication_state={self._communication_state}, transceiver_information={self._transceiver_information}, heading={self._heading}, rate_of_turn={self._rate_of_turn}, navigation_status={self._navigation_status}]'


class Pgn129039Class(NMEA2000DecodedMsg):

    _pgn = 129039
    _name = 'AIS Class B Position Report'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BiiiBHHHBHBBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_longitude', '_latitude', '_position_accuracy', '_RAIM', '_timestamp', '_COG', '_SOG', '_communication_state', '_transceiver_info', '_heading', '_unit_type', '_band', '_handle_msg22', '_AIS_mode', '_AIS_communication_state')

    _static_size = 26

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }
    _timestamp_enum = {
        60: 'Not available',
        61: 'Manual input mode',
        62: 'Dead reckoning mode',
        63: 'Positioning system is inoperative'
        }
    _transceiver_info_enum = {
        0: 'Channel A VDL reception',
        1: 'Channel B VDL reception',
        2: 'Channel A VDL transmission',
        3: 'Channel B VDL transmission',
        4: 'Own information not broadcast',
        5: 'Reserved',
        6: 'Reserved'
        }
    _AIS_mode_enum = {
        0: 'Autonomous',
        1: 'Assigned'
        }
    _AIS_communication_state_enum = {
        0: 'SOTDMA',
        1: 'ITDMA'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def position_accuracy(self) -> int:
        return self._position_accuracy

    @property
    def RAIM(self) -> int:
        return self._RAIM

    @property
    def timestamp(self) -> int:
        return self._timestamp

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @property
    def communication_state(self) -> int:
        return self._communication_state

    @property
    def transceiver_info(self) -> int:
        return self._transceiver_info

    @property
    def heading(self) -> float:
        return self._heading

    @property
    def unit_type(self) -> int:
        return self._unit_type

    @property
    def band(self) -> int:
        return self._band

    @property
    def handle_msg22(self) -> int:
        return self._handle_msg22

    @property
    def AIS_mode(self) -> int:
        return self._AIS_mode

    @property
    def AIS_communication_state(self) -> int:
        return self._AIS_communication_state

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    @property
    def timestamp_text(self) -> str:
        return self._timestamp_enum.get(self._timestamp, 'timestamp key error')

    @property
    def transceiver_info_text(self) -> str:
        return self._transceiver_info_enum.get(self._transceiver_info, 'transceiver_info key error')

    @property
    def AIS_mode_text(self) -> str:
        return self._AIS_mode_enum.get(self._AIS_mode, 'AIS_mode key error')

    @property
    def AIS_communication_state_text(self) -> str:
        return self._AIS_communication_state_enum.get(self._AIS_communication_state, 'AIS_communication_state key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._longitude = check_convert_float(val[2], 0x7fffffff, 1e-07)
        self._latitude = check_convert_float(val[3], 0x7fffffff, 1e-07)
        self._position_accuracy = val[4] & 0x1
        self._RAIM = (val[4] >> 1) & 0x1
        self._timestamp = (val[4] >> 2) & 0x3F
        self._COG = check_convert_float(val[5], 0xffff, 0.005729577951308233)
        self._SOG = check_convert_float(val[6], 0xffff, 0.01)
        word = val[7] + (val[8] << 16)
        self._communication_state = word & 0x7FFFF
        word = val[7] + (val[8] << 16)
        self._transceiver_info = (word >> 19) & 0x1F
        self._heading = check_convert_float(val[9], 0xffff, 0.005729577951308233)
        self._unit_type = (val[11] >> 2) & 0x1
        self._band = (val[11] >> 5) & 0x1
        self._handle_msg22 = (val[11] >> 6) & 0x1
        self._AIS_mode = (val[11] >> 7) & 0x1
        self._AIS_communication_state = val[12] & 0x1
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        v1 = int(self._longitude / 1e-07)
        v2 = int(self._latitude / 1e-07)
        v3 = (self._position_accuracy & 0x1) << 0
        v3 |= (self._RAIM & 0x1) << 1
        v3 |= (self._timestamp & 0x3f) << 2
        v4 = int(self._COG / 0.005729577951308233)
        v5 = int(self._SOG / 0.01)
        v6 = (self._communication_state & 0x7ffff) << 0
        v6 |= (self._transceiver_info & 0x1f) << 19
        v7 = int(self._heading / 0.005729577951308233)
        v8 = 0xff
        v9 = 0x3 << 0
        v10 = (self._unit_type & 0x1) << 2
        v10 |= 0x1 << 3
        v10 |= 0x1 << 4
        v10 |= (self._band & 0x1) << 5
        v10 |= (self._handle_msg22 & 0x1) << 6
        v10 |= (self._AIS_mode & 0x1) << 7
        v11 = (self._AIS_communication_state & 0x1) << 0
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)
        return buffer

    def from_protobuf(self, message: Pgn129039ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._longitude = message.longitude
        self._latitude = message.latitude
        self._position_accuracy = message.position_accuracy
        self._RAIM = message.RAIM
        self._timestamp = message.timestamp
        self._COG = message.COG
        self._SOG = message.SOG
        self._communication_state = message.communication_state
        self._transceiver_info = message.transceiver_info
        self._heading = message.heading
        self._unit_type = message.unit_type
        self._band = message.band
        self._handle_msg22 = message.handle_msg22
        self._AIS_mode = message.AIS_mode
        self._AIS_communication_state = message.AIS_communication_state

    def as_protobuf(self) -> Pgn129039ClassPb:
        message = Pgn129039ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.longitude = self._longitude
        message.latitude = self._latitude
        message.position_accuracy = self._position_accuracy
        message.RAIM = self._RAIM
        message.timestamp = self._timestamp
        message.COG = self._COG
        message.SOG = self._SOG
        message.communication_state = self._communication_state
        message.transceiver_info = self._transceiver_info
        message.heading = self._heading
        message.unit_type = self._unit_type
        message.band = self._band
        message.handle_msg22 = self._handle_msg22
        message.AIS_mode = self._AIS_mode
        message.AIS_communication_state = self._AIS_communication_state
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129039ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, longitude={self._longitude}, latitude={self._latitude}, position_accuracy={self._position_accuracy}, RAIM={self._RAIM}, timestamp={self._timestamp}, COG={self._COG}, SOG={self._SOG}, communication_state={self._communication_state}, transceiver_info={self._transceiver_info}, heading={self._heading}, unit_type={self._unit_type}, band={self._band}, handle_msg22={self._handle_msg22}, AIS_mode={self._AIS_mode}, AIS_communication_state={self._AIS_communication_state}]'


class Pgn129540Class(NMEA2000DecodedMsg):

    class Satellites_DataClass:

        _struct_str_0 = struct.Struct('<BhhhIB')
        _struct_str_0_size = _struct_str_0.size
        __slots__ = ('_satellite_number', '_elevation', '_azimuth', '_signal_noise_ratio', '_range_residuals', '_status')

        _static_size = 12

        @classmethod
        def size(cls):
            return cls._static_size

        @staticmethod
        def variable_size() -> bool:
            return False


        _status_enum = {
            0: 'Not tracked',
            1: 'Tracked',
            2: 'Used',
            3: 'Not tracked+Diff',
            4: 'Tracked+Diff',
            5: 'Used+Diff'
            }

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def satellite_number(self) -> int:
            return self._satellite_number

        @property
        def elevation(self) -> float:
            return self._elevation

        @property
        def azimuth(self) -> float:
            return self._azimuth

        @property
        def signal_noise_ratio(self) -> float:
            return self._signal_noise_ratio

        @property
        def range_residuals(self) -> int:
            return self._range_residuals

        @property
        def status(self) -> int:
            return self._status

        @property
        def status_text(self) -> str:
            return self._status_enum.get(self._status, 'status key error')

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
            self._satellite_number = val[0]
            self._elevation = check_convert_float(val[1], 0x7fff, 0.005729577951308233)
            self._azimuth = check_convert_float(val[2], 0x7fff, 0.005729577951308233)
            self._signal_noise_ratio = check_convert_float(val[3], 0x7fff, 0.01)
            self._range_residuals = val[4]
            self._status = val[5] & 0xF
            return self

        def encode_payload(self, buffer, start_byte):
            v0 = int(self._elevation / 0.005729577951308233)
            v1 = int(self._azimuth / 0.005729577951308233)
            v2 = int(self._signal_noise_ratio / 0.01)
            v3 = (self._status & 0xf) << 0
            v3 |= 0xf << 4
            self._struct_str_0.pack_into(buffer, 0 + start_byte, self._satellite_number, v0, v1, v2, self._range_residuals, v3)

        def from_protobuf(self, message: Pgn129540ClassPb.Satellites_DataClassPb):
            self._satellite_number = message.satellite_number
            self._elevation = message.elevation
            self._azimuth = message.azimuth
            self._signal_noise_ratio = message.signal_noise_ratio
            self._range_residuals = message.range_residuals
            self._status = message.status

        def as_protobuf(self) -> Pgn129540ClassPb.Satellites_DataClassPb:
            message = Pgn129540ClassPb.Satellites_DataClassPb()
            message.satellite_number = self._satellite_number
            message.elevation = self._elevation
            message.azimuth = self._azimuth
            message.signal_noise_ratio = self._signal_noise_ratio
            message.range_residuals = self._range_residuals
            message.status = self._status
            return message

        def __str__(self):
            return f'(Satellites_DataClass) [satellite_number={self._satellite_number}, elevation={self._elevation}, azimuth={self._azimuth}, signal_noise_ratio={self._signal_noise_ratio}, range_residuals={self._range_residuals}, status={self._status}]'


    _pgn = 129540
    _name = 'GNSS Sats in View'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_mode', '_sats_in_view', '_satellites_data')

    _static_size = 3

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _mode_enum = {
        3: 'Range residuals used to calculate position'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def mode(self) -> int:
        return self._mode

    @property
    def sats_in_view(self) -> int:
        return self._sats_in_view

    @property
    def satellites_data(self) -> list:
        return self._satellites_data

    @property
    def mode_text(self) -> str:
        return self._mode_enum.get(self._mode, 'mode key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._mode = val[1] & 0x3
        self._sats_in_view = check_valid(val[2], 255, 0)
        start_byte = self._static_size
        self._satellites_data = []
        for i in range(0, self.sats_in_view):
            self._satellites_data.append(self.Satellites_DataClass().decode_payload(payload, start_byte))
            start_byte += self.Satellites_DataClass.size()
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._mode & 0x3) << 0
        v0 |= 0x3f << 2
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, self._sats_in_view)
        for repeat_field in self._satellites_data:
            repeat_field.encode_payload(buffer, start_byte)
            start_byte += self.Satellites_DataClass.size()
        return buffer

    def from_protobuf(self, message: Pgn129540ClassPb):
        self._system_id = message.system_id
        self._mode = message.mode
        self._sats_in_view = message.sats_in_view
        self._satellites_data = []
        for sub_set in message.satellites_data:
            self._satellites_data.append(self.Satellites_DataClass(protobuf=sub_set))

    def as_protobuf(self) -> Pgn129540ClassPb:
        message = Pgn129540ClassPb()
        message.system_id = self._system_id
        message.mode = self._mode
        message.sats_in_view = self._sats_in_view
        for sub_set in self._satellites_data:
            message.satellites_data.append(sub_set.as_protobuf())
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129540ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, mode={self._mode}, sats_in_view={self._sats_in_view}, satellites_data={self._satellites_data}]'


class Pgn129794Class(NMEA2000DecodedMsg):

    _pgn = 129794
    _name = 'AIS Class A Static and Voyage Related Data'
    _proprietary = False
    _struct_str_0 = struct.Struct('<Bii')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<BhhhhHIh')
    _struct_str_1_size = _struct_str_1.size
    _struct_str_2 = struct.Struct('<BB')
    _struct_str_2_size = _struct_str_2.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_IMO_number', '_callsign', '_ship_name', '_type_of_ship', '_length', '_beam', '_position_from_starboard', '_position_from_bow', '_ETA_date', '_ETA_time', '_draft', '_destination', '_AIS_version', '_GNSS_type', '_DTE', '_AIS_transceiver_info')

    _static_size = 75

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }
    _type_of_ship_enum = 'Type of ship'
    _DTE_enum = {
        0: 'available',
        1: 'not available'
        }
    _AIS_transceiver_info_enum = {
        0: 'Channel A VDL reception',
        1: 'Channel B VDL reception',
        2: 'Channel A VDL transmission',
        3: 'Channel B VDL transmission',
        4: 'Own information not broadcast',
        5: 'Reserved'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def IMO_number(self) -> int:
        return self._IMO_number

    @property
    def callsign(self) -> str:
        return self._callsign

    @property
    def ship_name(self) -> str:
        return self._ship_name

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @property
    def position_from_bow(self) -> float:
        return self._position_from_bow

    @property
    def ETA_date(self) -> int:
        return self._ETA_date

    @property
    def ETA_time(self) -> float:
        return self._ETA_time

    @property
    def draft(self) -> float:
        return self._draft

    @property
    def destination(self) -> str:
        return self._destination

    @property
    def AIS_version(self) -> int:
        return self._AIS_version

    @property
    def GNSS_type(self) -> int:
        return self._GNSS_type

    @property
    def DTE(self) -> int:
        return self._DTE

    @property
    def AIS_transceiver_info(self) -> int:
        return self._AIS_transceiver_info

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    @property
    def DTE_text(self) -> str:
        return self._DTE_enum.get(self._DTE, 'DTE key error')

    @property
    def AIS_transceiver_info_text(self) -> str:
        return self._AIS_transceiver_info_enum.get(self._AIS_transceiver_info, 'AIS_transceiver_info key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._IMO_number = val[2]
        self._callsign = clean_string(payload[9 + start_byte: 16 + start_byte])
        self._ship_name = clean_string(payload[16 + start_byte: 36 + start_byte])
        val = self._struct_str_1.unpack_from(payload, 36 + start_byte)
        self._type_of_ship = val[0]
        self._length = check_convert_float(val[1], 0x7fff, 0.1)
        self._beam = check_convert_float(val[2], 0x7fff, 0.1)
        self._position_from_starboard = check_convert_float(val[3], 0x7fff, 0.1)
        self._position_from_bow = check_convert_float(val[4], 0x7fff, 0.1)
        self._ETA_date = val[5]
        self._ETA_time = check_convert_float(val[6], 0xffffffff, 0.0001)
        self._draft = check_convert_float(val[7], 0x7fff, 0.01)
        self._destination = clean_string(payload[53 + start_byte: 73 + start_byte])
        val = self._struct_str_2.unpack_from(payload, 73 + start_byte)
        self._AIS_version = val[0] & 0x3
        self._GNSS_type = (val[0] >> 2) & 0xF
        self._DTE = (val[0] >> 6) & 0x1
        self._AIS_transceiver_info = val[1] & 0x1F
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, self._IMO_number)
        insert_string(buffer, 9 + start_byte, 7, self._callsign)
        insert_string(buffer, 16 + start_byte, 20, self._ship_name)
        v0 = int(self._length / 0.1)
        v1 = int(self._beam / 0.1)
        v2 = int(self._position_from_starboard / 0.1)
        v3 = int(self._position_from_bow / 0.1)
        v4 = int(self._ETA_time / 0.0001)
        v5 = int(self._draft / 0.01)
        self._struct_str_1.pack_into(buffer, 36 + start_byte, self._type_of_ship, v0, v1, v2, v3, self._ETA_date, v4, v5)
        insert_string(buffer, 53 + start_byte, 20, self._destination)
        v0 = (self._AIS_version & 0x3) << 0
        v0 |= (self._GNSS_type & 0xf) << 2
        v0 |= (self._DTE & 0x1) << 6
        v0 |= 0x1 << 7
        v1 = (self._AIS_transceiver_info & 0x1f) << 0
        self._struct_str_2.pack_into(buffer, 73 + start_byte, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129794ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._IMO_number = message.IMO_number
        self._callsign = message.callsign
        self._ship_name = message.ship_name
        self._type_of_ship = message.type_of_ship
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard
        self._position_from_bow = message.position_from_bow
        self._ETA_date = message.ETA_date
        self._ETA_time = message.ETA_time
        self._draft = message.draft
        self._destination = message.destination
        self._AIS_version = message.AIS_version
        self._GNSS_type = message.GNSS_type
        self._DTE = message.DTE
        self._AIS_transceiver_info = message.AIS_transceiver_info

    def as_protobuf(self) -> Pgn129794ClassPb:
        message = Pgn129794ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.IMO_number = self._IMO_number
        message.callsign = self._callsign
        message.ship_name = self._ship_name
        message.type_of_ship = self._type_of_ship
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.ETA_date = self._ETA_date
        message.ETA_time = self._ETA_time
        message.draft = self._draft
        message.destination = self._destination
        message.AIS_version = self._AIS_version
        message.GNSS_type = self._GNSS_type
        message.DTE = self._DTE
        message.AIS_transceiver_info = self._AIS_transceiver_info
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129794ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, IMO_number={self._IMO_number}, callsign={self._callsign}, ship_name={self._ship_name}, type_of_ship={self._type_of_ship}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}, position_from_bow={self._position_from_bow}, ETA_date={self._ETA_date}, ETA_time={self._ETA_time}, draft={self._draft}, destination={self._destination}, AIS_version={self._AIS_version}, GNSS_type={self._GNSS_type}, DTE={self._DTE}, AIS_transceiver_info={self._AIS_transceiver_info}]'


class Pgn129809Class(NMEA2000DecodedMsg):

    _pgn = 129809
    _name = 'AIS Class B static data (msg 24 Part A)'
    _proprietary = False
    _struct_str_0 = struct.Struct('<Bi')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_ship_name')

    _static_size = 25

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def ship_name(self) -> str:
        return self._ship_name

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._ship_name = clean_string(payload[5 + start_byte: 25 + start_byte])
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi)
        insert_string(buffer, 5 + start_byte, 20, self._ship_name)
        return buffer

    def from_protobuf(self, message: Pgn129809ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._ship_name = message.ship_name

    def as_protobuf(self) -> Pgn129809ClassPb:
        message = Pgn129809ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.ship_name = self._ship_name
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129809ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, ship_name={self._ship_name}]'


class Pgn129810Class(NMEA2000DecodedMsg):

    _pgn = 129810
    _name = 'AIS Class B static data (msg 24 Part B)'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BiB')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<hhhhiB')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_type_of_ship', '_vendor_id', '_call_sign', '_length', '_beam', '_position_from_starboard', '_position_from_bow', '_mothership_mmsi')

    _static_size = 33

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }
    _type_of_ship_enum = 'Type of ship'

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def vendor_id(self) -> str:
        return self._vendor_id

    @property
    def call_sign(self) -> str:
        return self._call_sign

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @property
    def position_from_bow(self) -> float:
        return self._position_from_bow

    @property
    def mothership_mmsi(self) -> int:
        return self._mothership_mmsi

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[0] & 0x3F
        self._repeat_indicator = (val[0] >> 6) & 0x3
        self._mmsi = val[1]
        self._type_of_ship = val[2]
        self._vendor_id = clean_string(payload[6 + start_byte: 13 + start_byte])
        self._call_sign = clean_string(payload[13 + start_byte: 20 + start_byte])
        val = self._struct_str_1.unpack_from(payload, 20 + start_byte)
        self._length = check_convert_float(val[0], 0x7fff, 0.1)
        self._beam = check_convert_float(val[1], 0x7fff, 0.1)
        self._position_from_starboard = check_convert_float(val[2], 0x7fff, 0.1)
        self._position_from_bow = check_convert_float(val[3], 0x7fff, 0.1)
        self._mothership_mmsi = val[4]
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._message_id & 0x3f) << 0
        v0 |= (self._repeat_indicator & 0x3) << 6
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, self._mmsi, self._type_of_ship)
        insert_string(buffer, 6 + start_byte, 7, self._vendor_id)
        insert_string(buffer, 13 + start_byte, 7, self._call_sign)
        v0 = int(self._length / 0.1)
        v1 = int(self._beam / 0.1)
        v2 = int(self._position_from_starboard / 0.1)
        v3 = int(self._position_from_bow / 0.1)
        v4 = 0x3 << 0
        v4 |= 0x3f << 2
        self._struct_str_1.pack_into(buffer, 20 + start_byte, v0, v1, v2, v3, self._mothership_mmsi, v4)
        return buffer

    def from_protobuf(self, message: Pgn129810ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._type_of_ship = message.type_of_ship
        self._vendor_id = message.vendor_id
        self._call_sign = message.call_sign
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard
        self._position_from_bow = message.position_from_bow
        self._mothership_mmsi = message.mothership_mmsi

    def as_protobuf(self) -> Pgn129810ClassPb:
        message = Pgn129810ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        message.position_from_bow = self._position_from_bow
        message.mothership_mmsi = self._mothership_mmsi
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129810ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, type_of_ship={self._type_of_ship}, vendor_id={self._vendor_id}, call_sign={self._call_sign}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}, position_from_bow={self._position_from_bow}, mothership_mmsi={self._mothership_mmsi}]'


class Pgn130306Class(NMEA2000DecodedMsg):

    _pgn = 130306
    _name = 'Wind Data'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BhHBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_wind_speed', '_wind_angle', '_reference')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _reference_enum = {
        0: 'True (referenced to North)',
        1: 'Magnetic',
        2: 'Apparent',
        3: 'True (boat referenced)',
        4: 'True (water referenced)',
        6: 'Error',
        7: 'Unavailable'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def wind_speed(self) -> float:
        return self._wind_speed

    @property
    def wind_angle(self) -> float:
        return self._wind_angle

    @property
    def reference(self) -> int:
        return self._reference

    @property
    def reference_text(self) -> str:
        return self._reference_enum.get(self._reference, 'reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._wind_speed = check_convert_float(val[1], 0x7fff, 0.01)
        self._wind_angle = check_convert_float(val[2], 0xffff, 0.005729577951308233)
        self._reference = (val[3] >> 5) & 0x7
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._wind_speed / 0.01)
        v1 = int(self._wind_angle / 0.005729577951308233)
        v2 = 0x1f << 0
        v2 |= (self._reference & 0x7) << 5
        v3 = 0xffff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130306ClassPb):
        self._system_id = message.system_id
        self._wind_speed = message.wind_speed
        self._wind_angle = message.wind_angle
        self._reference = message.reference

    def as_protobuf(self) -> Pgn130306ClassPb:
        message = Pgn130306ClassPb()
        message.system_id = self._system_id
        message.wind_speed = self._wind_speed
        message.wind_angle = self._wind_angle
        message.reference = self._reference
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130306ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, wind_speed={self._wind_speed}, wind_angle={self._wind_angle}, reference={self._reference}]'


class Pgn130310Class(NMEA2000DecodedMsg):

    _pgn = 130310
    _name = 'Environmental Parameters'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHHHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_water_temperature', '_outside_air_temperature', '_atmospheric_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def water_temperature(self) -> float:
        return self._water_temperature

    @property
    def outside_air_temperature(self) -> float:
        return self._outside_air_temperature

    @property
    def atmospheric_pressure(self) -> float:
        return self._atmospheric_pressure

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._water_temperature = check_convert_float(val[1], 0xffff, 0.01, -273.15)
        self._outside_air_temperature = check_convert_float(val[2], 0xffff, 0.01, -273.15)
        self._atmospheric_pressure = check_convert_float(val[3], 0xffff, 100.0)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int((self._water_temperature - -273.15) / 0.01)
        v1 = int((self._outside_air_temperature - -273.15) / 0.01)
        v2 = int(self._atmospheric_pressure / 100.0)
        v3 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130310ClassPb):
        self._system_id = message.system_id
        self._water_temperature = message.water_temperature
        self._outside_air_temperature = message.outside_air_temperature
        self._atmospheric_pressure = message.atmospheric_pressure

    def as_protobuf(self) -> Pgn130310ClassPb:
        message = Pgn130310ClassPb()
        message.system_id = self._system_id
        message.water_temperature = self._water_temperature
        message.outside_air_temperature = self._outside_air_temperature
        message.atmospheric_pressure = self._atmospheric_pressure
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130310ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, water_temperature={self._water_temperature}, outside_air_temperature={self._outside_air_temperature}, atmospheric_pressure={self._atmospheric_pressure}]'


class Pgn130311Class(NMEA2000DecodedMsg):

    _pgn = 130311
    _name = 'Environmental Parameters'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBHhH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_temperature_instance', '_humidity_instance', '_temperature', '_humidity', '_atmospheric_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _humidity_instance_enum = {
        0: 'Inside',
        1: 'Outside'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def humidity_instance(self) -> int:
        return self._humidity_instance

    @property
    def temperature(self) -> float:
        return self._temperature

    @property
    def humidity(self) -> float:
        return self._humidity

    @property
    def atmospheric_pressure(self) -> float:
        return self._atmospheric_pressure

    @property
    def humidity_instance_text(self) -> str:
        return self._humidity_instance_enum.get(self._humidity_instance, 'humidity_instance key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._temperature_instance = val[1] & 0x3F
        self._humidity_instance = (val[1] >> 6) & 0x3
        self._temperature = check_convert_float(val[2], 0xffff, 0.01, -273.15)
        self._humidity = check_convert_float(val[3], 0x7fff, 0.004)
        self._atmospheric_pressure = check_convert_float(val[4], 0xffff, 100.0)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = (self._temperature_instance & 0x3f) << 0
        v0 |= (self._humidity_instance & 0x3) << 6
        v1 = int((self._temperature - -273.15) / 0.01)
        v2 = int(self._humidity / 0.004)
        v3 = int(self._atmospheric_pressure / 100.0)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, v0, v1, v2, v3)
        return buffer

    def from_protobuf(self, message: Pgn130311ClassPb):
        self._system_id = message.system_id
        self._temperature_instance = message.temperature_instance
        self._humidity_instance = message.humidity_instance
        self._temperature = message.temperature
        self._humidity = message.humidity
        self._atmospheric_pressure = message.atmospheric_pressure

    def as_protobuf(self) -> Pgn130311ClassPb:
        message = Pgn130311ClassPb()
        message.system_id = self._system_id
        message.temperature_instance = self._temperature_instance
        message.humidity_instance = self._humidity_instance
        message.temperature = self._temperature
        message.humidity = self._humidity
        message.atmospheric_pressure = self._atmospheric_pressure
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130311ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, temperature_instance={self._temperature_instance}, humidity_instance={self._humidity_instance}, temperature={self._temperature}, humidity={self._humidity}, atmospheric_pressure={self._atmospheric_pressure}]'


class Pgn130312Class(NMEA2000DecodedMsg):

    _pgn = 130312
    _name = 'Temperature'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBBHHB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_temperature_instance', '_temperature_source', '_actual_temperature', '_set_temperature')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _temperature_source_enum = 'Temperature Source'

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def temperature_source(self) -> int:
        return self._temperature_source

    @property
    def actual_temperature(self) -> float:
        return self._actual_temperature

    @property
    def set_temperature(self) -> float:
        return self._set_temperature

    @property
    def temperature_source_text(self) -> str:
        return resolve_global_enum(self._temperature_source_enum, self._temperature_source)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._temperature_instance = val[1]
        self._temperature_source = val[2]
        self._actual_temperature = check_convert_float(val[3], 0xffff, 0.01, -273.15)
        self._set_temperature = check_convert_float(val[4], 0xffff, 0.01, -273.15)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int((self._actual_temperature - -273.15) / 0.01)
        v1 = int((self._set_temperature - -273.15) / 0.01)
        v2 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, self._temperature_instance, self._temperature_source, v0, v1, v2)
        return buffer

    def from_protobuf(self, message: Pgn130312ClassPb):
        self._system_id = message.system_id
        self._temperature_instance = message.temperature_instance
        self._temperature_source = message.temperature_source
        self._actual_temperature = message.actual_temperature
        self._set_temperature = message.set_temperature

    def as_protobuf(self) -> Pgn130312ClassPb:
        message = Pgn130312ClassPb()
        message.system_id = self._system_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130312ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, temperature_instance={self._temperature_instance}, temperature_source={self._temperature_source}, actual_temperature={self._actual_temperature}, set_temperature={self._set_temperature}]'


class Pgn130314Class(NMEA2000DecodedMsg):

    _pgn = 130314
    _name = 'Actual Pressure'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBBIB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_pressure_instance', '_pressure_source', '_pressure')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _pressure_source_enum = {
        0: 'Atmospheric',
        1: 'Water',
        2: 'Steam',
        3: 'Compressed Air',
        4: 'Hydraulic'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def pressure_instance(self) -> int:
        return self._pressure_instance

    @property
    def pressure_source(self) -> int:
        return self._pressure_source

    @property
    def pressure(self) -> float:
        return self._pressure

    @property
    def pressure_source_text(self) -> str:
        return self._pressure_source_enum.get(self._pressure_source, 'pressure_source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._pressure_instance = val[1]
        self._pressure_source = val[2]
        self._pressure = check_convert_float(val[3], 0xffffffff, 0.1)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._pressure / 0.1)
        v1 = 0xff
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, self._pressure_instance, self._pressure_source, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn130314ClassPb):
        self._system_id = message.system_id
        self._pressure_instance = message.pressure_instance
        self._pressure_source = message.pressure_source
        self._pressure = message.pressure

    def as_protobuf(self) -> Pgn130314ClassPb:
        message = Pgn130314ClassPb()
        message.system_id = self._system_id
        message.pressure_instance = self._pressure_instance
        message.pressure_source = self._pressure_source
        message.pressure = self._pressure
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130314ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, pressure_instance={self._pressure_instance}, pressure_source={self._pressure_source}, pressure={self._pressure}]'


class Pgn130316Class(NMEA2000DecodedMsg):

    _pgn = 130316
    _name = 'Temperature Extended Range'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBBHBH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_temperature_instance', '_temperature_source', '_actual_temperature', '_set_temperature')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _temperature_source_enum = 'Temperature Source'

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def temperature_source(self) -> int:
        return self._temperature_source

    @property
    def actual_temperature(self) -> float:
        return self._actual_temperature

    @property
    def set_temperature(self) -> float:
        return self._set_temperature

    @property
    def temperature_source_text(self) -> str:
        return resolve_global_enum(self._temperature_source_enum, self._temperature_source)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._temperature_instance = val[1]
        self._temperature_source = val[2]
        word = val[3] + (val[4] << 16)
        self._actual_temperature = check_convert_float(word, 0xffffff, 0.001, -273.15)
        self._set_temperature = check_convert_float(val[5], 0xffff, 0.1, -273.15)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int((self._actual_temperature - -273.15) / 0.001)
        v1 = int((self._set_temperature - -273.15) / 0.1)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, self._system_id, self._temperature_instance, self._temperature_source, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn130316ClassPb):
        self._system_id = message.system_id
        self._temperature_instance = message.temperature_instance
        self._temperature_source = message.temperature_source
        self._actual_temperature = message.actual_temperature
        self._set_temperature = message.set_temperature

    def as_protobuf(self) -> Pgn130316ClassPb:
        message = Pgn130316ClassPb()
        message.system_id = self._system_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130316ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, temperature_instance={self._temperature_instance}, temperature_source={self._temperature_source}, actual_temperature={self._actual_temperature}, set_temperature={self._set_temperature}]'


class Pgn130578Class(NMEA2000DecodedMsg):

    _pgn = 130578
    _name = 'Vessel Speed Components'
    _proprietary = False
    _struct_str_0 = struct.Struct('<hhhhhh')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_longitudinal_speed_water', '_transverse_speed_water', '_longitudinal_speed_ground', '_transverse_speed_ground', '_stern_speed_water', '_stern_speed_ground')

    _static_size = 12

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def longitudinal_speed_water(self) -> float:
        return self._longitudinal_speed_water

    @property
    def transverse_speed_water(self) -> float:
        return self._transverse_speed_water

    @property
    def longitudinal_speed_ground(self) -> float:
        return self._longitudinal_speed_ground

    @property
    def transverse_speed_ground(self) -> float:
        return self._transverse_speed_ground

    @property
    def stern_speed_water(self) -> float:
        return self._stern_speed_water

    @property
    def stern_speed_ground(self) -> float:
        return self._stern_speed_ground

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._longitudinal_speed_water = check_convert_float(val[0], 0x7fff, 0.001)
        self._transverse_speed_water = check_convert_float(val[1], 0x7fff, 0.001)
        self._longitudinal_speed_ground = check_convert_float(val[2], 0x7fff, 0.001)
        self._transverse_speed_ground = check_convert_float(val[3], 0x7fff, 0.001)
        self._stern_speed_water = check_convert_float(val[4], 0x7fff, 0.001)
        self._stern_speed_ground = check_convert_float(val[5], 0x7fff, 0.001)
        return self

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        start_byte = 0
        v0 = int(self._longitudinal_speed_water / 0.001)
        v1 = int(self._transverse_speed_water / 0.001)
        v2 = int(self._longitudinal_speed_ground / 0.001)
        v3 = int(self._transverse_speed_ground / 0.001)
        v4 = int(self._stern_speed_water / 0.001)
        v5 = int(self._stern_speed_ground / 0.001)
        self._struct_str_0.pack_into(buffer, 0 + start_byte, v0, v1, v2, v3, v4, v5)
        return buffer

    def from_protobuf(self, message: Pgn130578ClassPb):
        self._longitudinal_speed_water = message.longitudinal_speed_water
        self._transverse_speed_water = message.transverse_speed_water
        self._longitudinal_speed_ground = message.longitudinal_speed_ground
        self._transverse_speed_ground = message.transverse_speed_ground
        self._stern_speed_water = message.stern_speed_water
        self._stern_speed_ground = message.stern_speed_ground

    def as_protobuf(self) -> Pgn130578ClassPb:
        message = Pgn130578ClassPb()
        message.longitudinal_speed_water = self._longitudinal_speed_water
        message.transverse_speed_water = self._transverse_speed_water
        message.longitudinal_speed_ground = self._longitudinal_speed_ground
        message.transverse_speed_ground = self._transverse_speed_ground
        message.stern_speed_water = self._stern_speed_water
        message.stern_speed_ground = self._stern_speed_ground
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130578ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [longitudinal_speed_water={self._longitudinal_speed_water}, transverse_speed_water={self._transverse_speed_water}, longitudinal_speed_ground={self._longitudinal_speed_ground}, transverse_speed_ground={self._transverse_speed_ground}, stern_speed_water={self._stern_speed_water}, stern_speed_ground={self._stern_speed_ground}]'


class Pgn130842Mfg1857Class(NMEA2000DecodedMsg):

    _pgn = 130842
    _name = 'Simnet: AIS Class B static data (msg 24 Part B)'
    _proprietary = True
    _manufacturer_id = 1857
    _struct_str_0 = struct.Struct('<HBBBiB')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<hhh')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_message_id', '_repeat_indicator', '_mmsi', '_type_of_ship', '_vendor_id', '_call_sign', '_length', '_beam', '_position_from_starboard')

    _static_size = 30

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False

    _repeat_indicator_enum = {
        0: 'Initial',
        1: 'First retransmission',
        2: 'Second retransmission',
        3: 'Final retransmission'
        }
    _type_of_ship_enum = 'Type of ship'

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def manufacturer_id(self) -> int:
        return self._manufacturer_id

    @property
    def message_id(self) -> int:
        return self._message_id

    @property
    def repeat_indicator(self) -> int:
        return self._repeat_indicator

    @property
    def mmsi(self) -> int:
        return self._mmsi

    @property
    def type_of_ship(self) -> int:
        return self._type_of_ship

    @property
    def vendor_id(self) -> str:
        return self._vendor_id

    @property
    def call_sign(self) -> str:
        return self._call_sign

    @property
    def length(self) -> float:
        return self._length

    @property
    def beam(self) -> float:
        return self._beam

    @property
    def position_from_starboard(self) -> float:
        return self._position_from_starboard

    @property
    def repeat_indicator_text(self) -> str:
        return self._repeat_indicator_enum.get(self._repeat_indicator, 'repeat_indicator key error')

    @property
    def type_of_ship_text(self) -> str:
        return resolve_global_enum(self._type_of_ship_enum, self._type_of_ship)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._message_id = val[1] & 0x3F
        self._repeat_indicator = (val[1] >> 6) & 0x3
        self._mmsi = val[4]
        self._type_of_ship = val[5]
        self._vendor_id = clean_string(payload[10 + start_byte: 17 + start_byte])
        self._call_sign = clean_string(payload[17 + start_byte: 24 + start_byte])
        val = self._struct_str_1.unpack_from(payload, 24 + start_byte)
        self._length = check_convert_float(val[0], 0x7fff, 0.1)
        self._beam = check_convert_float(val[1], 0x7fff, 0.1)
        self._position_from_starboard = check_convert_float(val[2], 0x7fff, 0.1)
        return self

    def from_protobuf(self, message: Pgn130842Mfg1857ClassPb):
        self._message_id = message.message_id
        self._repeat_indicator = message.repeat_indicator
        self._mmsi = message.mmsi
        self._type_of_ship = message.type_of_ship
        self._vendor_id = message.vendor_id
        self._call_sign = message.call_sign
        self._length = message.length
        self._beam = message.beam
        self._position_from_starboard = message.position_from_starboard

    def as_protobuf(self) -> Pgn130842Mfg1857ClassPb:
        message = Pgn130842Mfg1857ClassPb()
        message.message_id = self._message_id
        message.repeat_indicator = self._repeat_indicator
        message.mmsi = self._mmsi
        message.type_of_ship = self._type_of_ship
        message.vendor_id = self._vendor_id
        message.call_sign = self._call_sign
        message.length = self._length
        message.beam = self._beam
        message.position_from_starboard = self._position_from_starboard
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130842Mfg1857ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [message_id={self._message_id}, repeat_indicator={self._repeat_indicator}, mmsi={self._mmsi}, type_of_ship={self._type_of_ship}, vendor_id={self._vendor_id}, call_sign={self._call_sign}, length={self._length}, beam={self._beam}, position_from_starboard={self._position_from_starboard}]'


#####################################################################
#         Generated class dictionary
#####################################################################
nmea2k_generated_classes = {
        65359: Pgn65359Mfg1851Class,
        65379: Pgn65379Mfg1851Class,
        126992: Pgn126992Class,
        126993: Pgn126993Class,
        126996: Pgn126996Class,
        127245: Pgn127245Class,
        127250: Pgn127250Class,
        127488: Pgn127488Class,
        127489: Pgn127489Class,
        127508: Pgn127508Class,
        128259: Pgn128259Class,
        128267: Pgn128267Class,
        129025: Pgn129025Class,
        129026: Pgn129026Class,
        129029: Pgn129029Class,
        129038: Pgn129038Class,
        129039: Pgn129039Class,
        129540: Pgn129540Class,
        129794: Pgn129794Class,
        129809: Pgn129809Class,
        129810: Pgn129810Class,
        130306: Pgn130306Class,
        130310: Pgn130310Class,
        130311: Pgn130311Class,
        130312: Pgn130312Class,
        130314: Pgn130314Class,
        130316: Pgn130316Class,
        130578: Pgn130578Class,
        130842: Pgn130842Mfg1857Class
        }
# end of generated file
