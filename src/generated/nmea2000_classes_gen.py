#   Python code generated by NMEA message router application (c) Sterwen Technology 2023
#   generated on 2023-09-18:19:09
#   do not modify code


import struct

from nmea2000.generated_base import *
from generated.nmea2000_pb2 import nmea2000_decoded_pb
from nmea2000.nmea2000_msg import NMEA2000Msg

from generated.nmea2000_classes_gen_pb2 import *


class Pgn126992Class(NMEA2000DecodedMsg):

    _pgn = 126992
    _name = 'System Time'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBHi')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_source', '_date', '_time')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    _source_enum = {
        0: 'GPS',
        1: 'GLONASS',
        2: 'Radio Station',
        3: 'Local Cesium clock',
        4: 'Local Rubidium clock',
        5: 'Local Crystal clock'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def source(self) -> int:
        return self._source

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @system_id.setter
    def system_id(self, value: int):
        self._system_id = value

    @source.setter
    def source(self, value: int):
        self._source = value

    @date.setter
    def date(self, value: int):
        self._date = value

    @time.setter
    def time(self, value: float):
        self._time = value

    @property
    def source_text(self) -> str:
        return self._source_enum.get(self._source, 'source key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._source = (val[1] << 4) & 0xF
        self._date = val[2]
        self._time = val[3] * 0.0001

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        v0 = int(self._time / 0.0001)
        self._struct_str_0.pack_into(buffer, 0, self._system_id, self._source, self._date, v0)
        return buffer

    def from_protobuf(self, message: Pgn126992ClassPb):
        self._system_id = message.system_id
        self._source = message.source
        self._date = message.date
        self._time = message.time

    def as_protobuf(self) -> Pgn126992ClassPb:
        message = Pgn126992ClassPb()
        message.system_id = self._system_id
        message.source = self._source
        message.date = self._date
        message.time = self._time
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126992ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, source={self._source}, date={self._date}, time={self._time}]'


class Pgn126993Class(NMEA2000DecodedMsg):

    _pgn = 126993
    _name = 'Heartbeat'
    _proprietary = False
    _struct_str_0 = struct.Struct('<hBBI')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_interval', '_status')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False



    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def interval(self) -> float:
        return self._interval

    @property
    def status(self) -> int:
        return self._status

    @interval.setter
    def interval(self, value: float):
        self._interval = value

    @status.setter
    def status(self, value: int):
        self._status = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._interval = val[0] * 10.0
        self._status = val[1]

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        v0 = int(self._interval / 10.0)
        self._struct_str_0.pack_into(buffer, 0, v0, self._status)
        return buffer

    def from_protobuf(self, message: Pgn126993ClassPb):
        self._interval = message.interval
        self._status = message.status

    def as_protobuf(self) -> Pgn126993ClassPb:
        message = Pgn126993ClassPb()
        message.interval = self._interval
        message.status = self._status
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126993ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [interval={self._interval}, status={self._status}]'


class Pgn126996Class(NMEA2000DecodedMsg):

    _pgn = 126996
    _name = 'Product Information'
    _proprietary = False
    _struct_str_0 = struct.Struct('<HH')
    _struct_str_0_size = _struct_str_0.size
    _struct_str_1 = struct.Struct('<BB')
    _struct_str_1_size = _struct_str_1.size
    __slots__ = ('_nmea2000_version', '_product_code', '_product_information', '_certification_level', '_load_equivalency')

    _static_size = 134

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False



    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def nmea2000_version(self) -> int:
        return self._nmea2000_version

    @property
    def product_code(self) -> int:
        return self._product_code

    @property
    def product_information(self) -> str:
        return self._product_information

    @property
    def certification_level(self) -> int:
        return self._certification_level

    @property
    def load_equivalency(self) -> int:
        return self._load_equivalency

    @nmea2000_version.setter
    def nmea2000_version(self, value: int):
        self._nmea2000_version = value

    @product_code.setter
    def product_code(self, value: int):
        self._product_code = value

    @product_information.setter
    def product_information(self, value: str):
        self._product_information = value

    @certification_level.setter
    def certification_level(self, value: int):
        self._certification_level = value

    @load_equivalency.setter
    def load_equivalency(self, value: int):
        self._load_equivalency = value

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._nmea2000_version = val[0]
        self._product_code = val[1]
        self._product_information = clean_string(payload[4 + start_byte: 132 + start_byte])
        val = self._struct_str_1.unpack_from(payload, 132 + start_byte)
        self._certification_level = val[0]
        self._load_equivalency = val[1]

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        self._struct_str_0.pack_into(buffer, 0, self._nmea2000_version, self._product_code)
        self._struct_str_1.pack_into(buffer, 132, self._certification_level, self._load_equivalency)
        return buffer

    def from_protobuf(self, message: Pgn126996ClassPb):
        self._nmea2000_version = message.nmea2000_version
        self._product_code = message.product_code
        self._product_information = message.product_information
        self._certification_level = message.certification_level
        self._load_equivalency = message.load_equivalency

    def as_protobuf(self) -> Pgn126996ClassPb:
        message = Pgn126996ClassPb()
        message.nmea2000_version = self._nmea2000_version
        message.product_code = self._product_code
        message.product_information = self._product_information
        message.certification_level = self._certification_level
        message.load_equivalency = self._load_equivalency
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn126996ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [nmea2000_version={self._nmea2000_version}, product_code={self._product_code}, product_information={self._product_information}, certification_level={self._certification_level}, load_equivalency={self._load_equivalency}]'


class Pgn129026Class(NMEA2000DecodedMsg):

    _pgn = 129026
    _name = 'COG & SOG, Rapid Update'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBhhH')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_COG_reference', '_COG', '_SOG')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    _COG_reference_enum = {
        0: 'True',
        1: 'Magnetic'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def COG_reference(self) -> int:
        return self._COG_reference

    @property
    def COG(self) -> float:
        return self._COG

    @property
    def SOG(self) -> float:
        return self._SOG

    @system_id.setter
    def system_id(self, value: int):
        self._system_id = value

    @COG_reference.setter
    def COG_reference(self, value: int):
        self._COG_reference = value

    @COG.setter
    def COG(self, value: float):
        self._COG = value

    @SOG.setter
    def SOG(self, value: float):
        self._SOG = value

    @property
    def COG_reference_text(self) -> str:
        return self._COG_reference_enum.get(self._COG_reference, 'COG_reference key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._COG_reference = val[1] & 0x3
        self._COG = val[2] * 0.005729577951308233
        self._SOG = val[3] * 0.01

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        v0 = int(self._COG / 0.005729577951308233)
        v1 = int(self._SOG / 0.01)
        self._struct_str_0.pack_into(buffer, 0, self._system_id, self._COG_reference, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn129026ClassPb):
        self._system_id = message.system_id
        self._COG_reference = message.COG_reference
        self._COG = message.COG
        self._SOG = message.SOG

    def as_protobuf(self) -> Pgn129026ClassPb:
        message = Pgn129026ClassPb()
        message.system_id = self._system_id
        message.COG_reference = self._COG_reference
        message.COG = self._COG
        message.SOG = self._SOG
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129026ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, COG_reference={self._COG_reference}, COG={self._COG}, SOG={self._SOG}]'


class Pgn129029Class(NMEA2000DecodedMsg):

    class Ref_StationsClass:

        _struct_str_0 = struct.Struct('<Bh')
        _struct_str_0_size = _struct_str_0.size
        __slots__ = ('_station_id', '_GNSS_type', '_age_DGNSS_correction')

        _static_size = 3

        @classmethod
        def size(cls):
            return cls._static_size

        @staticmethod
        def variable_size() -> bool:
            return False


        _GNSS_type_enum = 'GNSS type'

        def __init__(self, protobuf=None):
            if protobuf is not None:
                self.from_protobuf(protobuf)

        @property
        def station_id(self) -> int:
            return self._station_id

        @property
        def GNSS_type(self) -> int:
            return self._GNSS_type

        @property
        def age_DGNSS_correction(self) -> float:
            return self._age_DGNSS_correction

        @station_id.setter
        def station_id(self, value: int):
            self._station_id = value

        @GNSS_type.setter
        def GNSS_type(self, value: int):
            self._GNSS_type = value

        @age_DGNSS_correction.setter
        def age_DGNSS_correction(self, value: float):
            self._age_DGNSS_correction = value

        @property
        def GNSS_type_text(self) -> str:
            return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

        def decode_payload(self, payload, start_byte=0):
            val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
            self._station_id = val[0] & 0xF
            self._GNSS_type = (val[0] << 4) & 0xF
            self._age_DGNSS_correction = val[1] * 0.01

        def encode_payload(self) -> bytearray:
            buf_size = self.__class__.size()
            buffer = bytearray(buf_size)
            v0 = int(self._age_DGNSS_correction / 0.01)
            self._struct_str_0.pack_into(buffer, 0, self._station_id, self._GNSS_type, v0)
            return buffer

        def from_protobuf(self, message: Pgn129029ClassPb.Ref_StationsClassPb):
            self._station_id = message.station_id
            self._GNSS_type = message.GNSS_type
            self._age_DGNSS_correction = message.age_DGNSS_correction

        def as_protobuf(self) -> Pgn129029ClassPb.Ref_StationsClassPb:
            message = Pgn129029ClassPb.Ref_StationsClassPb()
            message.station_id = self._station_id
            message.GNSS_type = self._GNSS_type
            message.age_DGNSS_correction = self._age_DGNSS_correction
            return message


    _pgn = 129029
    _name = 'GNSS Position Data'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BHiqqqBBBhhiB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_date', '_time', '_latitude', '_longitude', '_altitude', '_method', '_GNSS_type', '_integrity', '_number_of_sv', '_HDOP', '_PDOP', '_geoidal_separation', '_nb_ref_stations', '_ref_stations')

    _static_size = 43

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    _GNSS_type_enum = 'GNSS type'
    _integrity_enum = {
        0: 'No integrity checking',
        1: 'Safe',
        2: 'Caution'
        }

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def date(self) -> int:
        return self._date

    @property
    def time(self) -> float:
        return self._time

    @property
    def latitude(self) -> float:
        return self._latitude

    @property
    def longitude(self) -> float:
        return self._longitude

    @property
    def altitude(self) -> float:
        return self._altitude

    @property
    def method(self) -> int:
        return self._method

    @property
    def GNSS_type(self) -> int:
        return self._GNSS_type

    @property
    def integrity(self) -> int:
        return self._integrity

    @property
    def number_of_sv(self) -> int:
        return self._number_of_sv

    @property
    def HDOP(self) -> float:
        return self._HDOP

    @property
    def PDOP(self) -> float:
        return self._PDOP

    @property
    def geoidal_separation(self) -> float:
        return self._geoidal_separation

    @property
    def nb_ref_stations(self) -> int:
        return self._nb_ref_stations

    @property
    def ref_stations(self) -> list:
        return self._ref_stations

    @system_id.setter
    def system_id(self, value: int):
        self._system_id = value

    @date.setter
    def date(self, value: int):
        self._date = value

    @time.setter
    def time(self, value: float):
        self._time = value

    @latitude.setter
    def latitude(self, value: float):
        self._latitude = value

    @longitude.setter
    def longitude(self, value: float):
        self._longitude = value

    @altitude.setter
    def altitude(self, value: float):
        self._altitude = value

    @method.setter
    def method(self, value: int):
        self._method = value

    @GNSS_type.setter
    def GNSS_type(self, value: int):
        self._GNSS_type = value

    @integrity.setter
    def integrity(self, value: int):
        self._integrity = value

    @number_of_sv.setter
    def number_of_sv(self, value: int):
        self._number_of_sv = value

    @HDOP.setter
    def HDOP(self, value: float):
        self._HDOP = value

    @PDOP.setter
    def PDOP(self, value: float):
        self._PDOP = value

    @geoidal_separation.setter
    def geoidal_separation(self, value: float):
        self._geoidal_separation = value

    @nb_ref_stations.setter
    def nb_ref_stations(self, value: int):
        self._nb_ref_stations = value

    @ref_stations.setter
    def ref_stations(self, value: list):
        self._ref_stations = value

    @property
    def GNSS_type_text(self) -> str:
        return resolve_global_enum(self._GNSS_type_enum, self._GNSS_type)

    @property
    def integrity_text(self) -> str:
        return self._integrity_enum.get(self._integrity, 'integrity key error')

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._date = val[1]
        self._time = val[2] * 0.0001
        self._latitude = val[3] * 1e-16
        self._longitude = val[4] * 1e-16
        self._altitude = val[5] * 1e-06
        self._method = val[6] & 0xF
        self._GNSS_type = (val[6] << 4) & 0xF
        self._integrity = val[7] & 0x3
        self._number_of_sv = val[8]
        self._HDOP = val[9] * 0.01
        self._PDOP = val[10] * 0.01
        self._geoidal_separation = val[11] * 0.01
        self._nb_ref_stations = check_valid(val[12], 255, 0)
        start_byte = self._static_size
        self._ref_stations = []
        for i in range(0, self.nb_ref_stations):
            self._ref_stations.append(self.Ref_StationsClass().decode_payload(payload, start_byte))
            start_byte += self.Ref_StationsClass.size()

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        v0 = int(self._time / 0.0001)
        v1 = int(self._latitude / 1e-16)
        v2 = int(self._longitude / 1e-16)
        v3 = int(self._altitude / 1e-06)
        v4 = int(self._HDOP / 0.01)
        v5 = int(self._PDOP / 0.01)
        v6 = int(self._geoidal_separation / 0.01)
        self._struct_str_0.pack_into(buffer, 0, self._system_id, self._date, v0, v1, v2, v3, self._method, self._GNSS_type, self._integrity, self._number_of_sv, v4, v5, v6, self._nb_ref_stations)
        return buffer

    def from_protobuf(self, message: Pgn129029ClassPb):
        self._system_id = message.system_id
        self._date = message.date
        self._time = message.time
        self._latitude = message.latitude
        self._longitude = message.longitude
        self._altitude = message.altitude
        self._method = message.method
        self._GNSS_type = message.GNSS_type
        self._integrity = message.integrity
        self._number_of_sv = message.number_of_sv
        self._HDOP = message.HDOP
        self._PDOP = message.PDOP
        self._geoidal_separation = message.geoidal_separation
        self._nb_ref_stations = message.nb_ref_stations
        self._ref_stations = []
        for sub_set in message.ref_stations:
            self._ref_stations.append(self.Ref_StationsClass(protobuf=sub_set))

    def as_protobuf(self) -> Pgn129029ClassPb:
        message = Pgn129029ClassPb()
        message.system_id = self._system_id
        message.date = self._date
        message.time = self._time
        message.latitude = self._latitude
        message.longitude = self._longitude
        message.altitude = self._altitude
        message.method = self._method
        message.GNSS_type = self._GNSS_type
        message.integrity = self._integrity
        message.number_of_sv = self._number_of_sv
        message.HDOP = self._HDOP
        message.PDOP = self._PDOP
        message.geoidal_separation = self._geoidal_separation
        message.nb_ref_stations = self._nb_ref_stations
        for sub_set in self._ref_stations:
            message.ref_stations.append(sub_set.as_protobuf())
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn129029ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, date={self._date}, time={self._time}, latitude={self._latitude}, longitude={self._longitude}, altitude={self._altitude}, method={self._method}, GNSS_type={self._GNSS_type}, integrity={self._integrity}, number_of_sv={self._number_of_sv}, HDOP={self._HDOP}, PDOP={self._PDOP}, geoidal_separation={self._geoidal_separation}, nb_ref_stations={self._nb_ref_stations}, ref_stations={self._ref_stations}]'


class Pgn130312Class(NMEA2000DecodedMsg):

    _pgn = 130312
    _name = 'Temperature'
    _proprietary = False
    _struct_str_0 = struct.Struct('<BBBhhB')
    _struct_str_0_size = _struct_str_0.size
    __slots__ = ('_system_id', '_temperature_instance', '_temperature_source', '_actual_temperature', '_set_temperature')

    _static_size = 8

    @classmethod
    def size(cls):
        return cls._static_size

    @staticmethod
    def variable_size() -> bool:
        return False


    _temperature_source_enum = 'Temperature Source'

    def __init__(self, message=None, protobuf=None):
        super().__init__(message, protobuf)

    @property
    def pgn(self) -> int:
        return self._pgn

    @property
    def name(self) -> str:
        return self._name

    @property
    def proprietary(self) -> bool:
        return self._proprietary

    @property
    def system_id(self) -> int:
        return self._system_id

    @property
    def temperature_instance(self) -> int:
        return self._temperature_instance

    @property
    def temperature_source(self) -> int:
        return self._temperature_source

    @property
    def actual_temperature(self) -> float:
        return self._actual_temperature

    @property
    def set_temperature(self) -> float:
        return self._set_temperature

    @system_id.setter
    def system_id(self, value: int):
        self._system_id = value

    @temperature_instance.setter
    def temperature_instance(self, value: int):
        self._temperature_instance = value

    @temperature_source.setter
    def temperature_source(self, value: int):
        self._temperature_source = value

    @actual_temperature.setter
    def actual_temperature(self, value: float):
        self._actual_temperature = value

    @set_temperature.setter
    def set_temperature(self, value: float):
        self._set_temperature = value

    @property
    def temperature_source_text(self) -> str:
        return resolve_global_enum(self._temperature_source_enum, self._temperature_source)

    def decode_payload(self, payload, start_byte=0):
        val = self._struct_str_0.unpack_from(payload, 0 + start_byte)
        self._system_id = val[0]
        self._temperature_instance = val[1]
        self._temperature_source = val[2]
        self._actual_temperature = val[3] * 0.01 + -273.15
        self._set_temperature = val[4] * 0.01 + -273.15

    def encode_payload(self) -> bytearray:
        buf_size = self.__class__.size()
        buffer = bytearray(buf_size)
        v0 = int((self._actual_temperature - -273.15) / 0.01)
        v1 = int((self._set_temperature - -273.15) / 0.01)
        self._struct_str_0.pack_into(buffer, 0, self._system_id, self._temperature_instance, self._temperature_source, v0, v1)
        return buffer

    def from_protobuf(self, message: Pgn130312ClassPb):
        self._system_id = message.system_id
        self._temperature_instance = message.temperature_instance
        self._temperature_source = message.temperature_source
        self._actual_temperature = message.actual_temperature
        self._set_temperature = message.set_temperature

    def as_protobuf(self) -> Pgn130312ClassPb:
        message = Pgn130312ClassPb()
        message.system_id = self._system_id
        message.temperature_instance = self._temperature_instance
        message.temperature_source = self._temperature_source
        message.actual_temperature = self._actual_temperature
        message.set_temperature = self._set_temperature
        return message

    def unpack_protobuf(self, protobuf: nmea2000_decoded_pb):
        payload = Pgn130312ClassPb()
        protobuf.payload.Unpack(payload)
        self.from_protobuf(payload)

    def __str__(self):
        return f'PGN{self._pgn}({self._name}) [system_id={self._system_id}, temperature_instance={self._temperature_instance}, temperature_source={self._temperature_source}, actual_temperature={self._actual_temperature}, set_temperature={self._set_temperature}]'


#####################################################################
#         Messages implementation classes
#####################################################################

#####################################################################
#         Generated class dictionary
#####################################################################
nmea2k_generated_classes = {
        126992: Pgn126992Class,
        126993: Pgn126993Class,
        126996: Pgn126996Class,
        129026: Pgn129026Class,
        129029: Pgn129029Class,
        130312: Pgn130312Class
        }
# end of generated file
