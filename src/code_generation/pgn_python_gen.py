# -------------------------------------------------------------------------------
# Name:        pgn_python_gen
# Purpose:     Python code generator for pgn supporting classes
#
# Author:      Laurent Carré
#
# Created:     23/11/2023
# Copyright:   (c) Laurent Carré Sterwen Technology 2021-2023
# Licence:     Eclipse Public License 2.0
# -------------------------------------------------------------------------------


import logging
import datetime


from code_generation.nmea2000_meta import (BitFieldAttributeDef, RepeatAttributeDef, ScalarAttributeDef, NMEA2000Meta,
                                           FieldSetMeta)

_logger = logging.getLogger("ShipDataServer." + __name__)


class PythonPGNGenerator:

    level_indent = ['', '    ', '        ', '            ', '                ']
    base_class = 'NMEA2000Payload'
    message_base_class = 'NMEA2000DecodedMsg'

    def __init__(self, output_file):

        try:
            self._of = open(output_file, 'w')
        except IOError as err:
            _logger.error("Python code generator - error opening output file %s:%s" % (output_file, err))
            raise
        _logger.info(f"Generating Python code in {output_file}")
        self._level = 0
        self._of.write('#   Python code generated by NMEA message router application (c) Sterwen Technology 2023\n')
        self._of.write('#   generated on %s\n' % datetime.datetime.now().strftime("%Y-%M-%d:%H:%M"))
        self._of.write('#   do not modify code\n\n\n')

        # generate imports
        self._of.write("import struct\n")
        self._of.write(f"\nfrom nmea2000.generated_base import {self.base_class}, {self.message_base_class}, check_valid\n")
        self._of.write("from generated.nmea2000_pb2 import nmea2000_decoded_pb\n")
        self._of.write("from nmea2000.nmea2000_msg import NMEA2000Msg\n")
        # self._of.write("from utilities.global_variables import MessageServerGlobals\n")
        self._of.write('\n')

    def close(self):
        self._of.close()

    def write_indent(self):
        self._of.write(self.level_indent[self._level])

    def write(self, output_str: str):
        self.write_indent()
        self._of.write(output_str)

    def inc_indent(self):
        self._level += 1

    def dec_indent(self):
        self._level -= 1

    def set_level(self, level):
        self._level = level

    def gen_classes(self, class_def_list: list, protobuf_conv):
        # add protobuf import
        if protobuf_conv:
            self._of.write("from generated.nmea2000_classes_gen_pb2 import *")
        # generate all classes
        for cls in class_def_list:
            self.gen_class(cls, protobuf_conv)
        self.set_level(0)
        self._of.write("\n#####################################################################\n")
        self._of.write("#         Messages implementation classes\n")
        self._of.write("#####################################################################\n")
        for cls in class_def_list:
            self.gen_message_class(cls, protobuf_conv)
        # now write the class dictionary
        self.set_level(0)
        self._of.write("\n#####################################################################\n")
        self._of.write("#         Generated class dictionary\n")
        self._of.write("#####################################################################\n")
        self._of.write("nmea2k_generated_classes = {\n")
        self.set_level(2)

        def write_cls_entry(cls_def: NMEA2000Meta):
            self._of.write(f"{cls_def.pgn}: {cls_def.msg_class_name}")

        for cls in class_def_list[:len(class_def_list)-1]:
            self.write_indent()
            write_cls_entry(cls)
            self._of.write(",\n")
        self.write_indent()
        write_cls_entry(class_def_list[len(class_def_list)-1])
        self._of.write("\n")
        self.write_indent()
        self._of.write("}\n")
        self._of.write("# end of generated file\n")

    def gen_class_variables(self, attributes, decode_str, last_attr):
        self.write_indent()
        self._of.write("_decode_struct = struct.Struct('%s')\n" % decode_str)
        self.write_indent()
        self._of.write("_decode_struct_size = _decode_struct.size\n")
        self.write_indent()
        self._of.write("__slots__ = (")
        for attr in attributes[:last_attr]:
            self._of.write("'%s', " % attr.variable)
        self._of.write("'%s')\n\n" % attributes[last_attr].variable)
        self.write_indent()
        self._of.write("@classmethod\n")
        self.write_indent()
        self._of.write("def size(cls) -> int:\n")
        self.inc_indent()
        self.write_indent()
        self._of.write(f"return cls._decode_struct_size\n\n")
        self.dec_indent()

    def gen_enums_definition(self, enums):
        # enums or enum reference
        for enum in enums:
            self.write_indent()
            self._of.write(f"_{enum.method}_enum = ")
            if enum.global_ref is not None:
                self._of.write(f"'{enum.global_ref}'\n")
            else:
                self._of.write("{\n")
                nb_enums = len(enum.enum_dict)
                count = 0
                self.inc_indent()
                for key, text in enum.enum_dict.items():
                    self.write_indent()
                    self._of.write(f"{key}: '{text}'")
                    if count < nb_enums - 1:
                        self._of.write(",\n")
                    else:
                        self._of.write("\n")
                    count += 1
                self.write_indent()
                self._of.write("}\n")
                self.dec_indent()
        self._of.write('\n')
        # enums end

    def gen_accessors_methods(self, attributes, enums):
        for attr in attributes:
            self.gen_getter(attr.method, attr.field_type)

        for attr in attributes:
            self.write_indent()
            self._of.write("@%s.setter\n" % attr.method)
            self.write_indent()
            self._of.write("def %s(self, value: %s):\n" % (attr.method, attr.field_type))
            self.inc_indent()
            self.write_indent()
            self._of.write("self.%s = value\n\n" % attr.variable)
            self.dec_indent()
        #
        # enums property
        for enum in enums:
            self.write_indent()
            self._of.write("@property\n")
            self.write_indent()
            self._of.write(f"def {enum.method}_text(self) -> str:\n")
            self.inc_indent()
            self.write_indent()
            if enum.global_ref is not None:
                self._of.write(f"return {self.base_class}.resolve_global_enum(self._{enum.method}_enum, self._{enum.method})\n\n")
            else:
                self._of.write(f"return self._{enum.method}_enum.get(self._{enum.method}, '{enum.method} key error')\n\n")
            self.dec_indent()

    def gen_decode_encode_methods(self, attributes, last_attr):
        #
        # decode method =================================================
        #
        self.write_indent()
        self._of.write("def decode_payload_segment(self, payload, from_byte):\n")
        self.inc_indent()
        self.write_indent()
        self._of.write("val = self._decode_struct.unpack_from(payload, from_byte)\n")
        for attr in attributes:
            self.write_indent()
            # print("Decode for", attr.method, attr.__class__.__name__)
            if isinstance(attr, ScalarAttributeDef):
                if attr.need_check:
                    self._of.write(f"self.{attr.variable} = check_valid(val[{attr.field_index}], {attr.invalid_mask}, {attr.default})")
                else:
                    self._of.write("self.%s = " % attr.variable)
                    if attr.scale is not None:
                        self._of.write("val[%d] * %s" % (attr.field_index, str(attr.scale)))
                    elif attr.field_type == "float":
                        self._of.write("float(val[%d])" % attr.field_index)
                    else:
                        self._of.write("val[%d]" % attr.field_index)
                    if attr.offset is not None:
                        self._of.write(" + %s" % str(attr.offset))
            elif isinstance(attr, BitFieldAttributeDef):
                # print(attr.method, attr.nb_slots, attr.bit_offset)
                if attr.nb_slots == 2:
                    self._of.write(f"word = val[{attr.field_index}] + val[{attr.field_index} + 1] << 16\n")
                    self.write_indent()
                    self._of.write(f"self.{attr.variable} = ")
                    if attr.bit_offset == 0:
                        self._of.write("word")
                    else:
                        self._of.write(f"(word >> {attr.bit_offset})")

                else:
                    self._of.write(f"self.{attr.variable} = ")
                    if attr.bit_offset == 0:
                        self._of.write(f"val[{attr.field_index}] ")
                    else:
                        self._of.write(f"(val[{attr.field_index}] << {attr.bit_offset}) ")
                self._of.write(f"& 0x{attr.mask:X}")

            elif isinstance(attr, RepeatAttributeDef):
                self._of.write("start_byte = self._decode_struct_size\n")
                self.write_indent()
                self._of.write(f"self.{attr.variable} = []\n")
                self.write_indent()
                self._of.write(f"for i in range(0, self.{attr.count_method}):\n")
                self.inc_indent()
                self.write_indent()
                self._of.write(f"self.{attr.variable}.append(self.{attr.class_name}().decode_payload_segment(payload, start_byte))\n")
                self.write_indent()
                self._of.write(f"start_byte += self.{attr.class_name}.size()")
                self.dec_indent()
            self._of.write("\n")
        self.dec_indent()
        self._of.write("\n")
        # encode method
        self.write_indent()
        self._of.write("def encode_payload_segment(self, from_byte):\n")
        self.inc_indent()

        val_encode = []
        numvi = 0
        # compute the size of the output buffer
        # fixed determined size
        self.write_indent()
        self._of.write(f"buf_size = self.__class__.size()")
        if isinstance(attributes[last_attr], RepeatAttributeDef):
            last_encoded_main_index = last_attr
            self._of.write(f" + (self.{attributes[last_attr].count_method} * self.{attributes[last_attr].class_name}.size())")
        else:
            last_encoded_main_index = len(attributes)

        self._of.write("\n")
        self.write_indent()
        self._of.write(f"buffer = bytearray(buf_size)\n")
        # self.write_indent()
        # first need to convert in int if float
        for attr in attributes[:last_encoded_main_index]:
            if attr.field_type == "float":
                vi = "v%d" % numvi
                numvi += 1
                val_encode.append(vi)
                self.write_indent()
                self._of.write("%s = int(" % vi)
                if attr.offset is not None:
                    self._of.write("(self.%s - %s)" % (attr.variable, attr.offset))
                else:
                    self._of.write("self.%s" % attr.variable)
                if attr.scale is not None:
                    self._of.write(" / %s" % attr.scale)
                self._of.write(")\n")
            else:
                val_encode.append("self.%s" % attr.variable)

        self.write_indent()
        self._of.write("self._decode_struct.pack_into(buffer, from_byte, ")
        for val in val_encode[:last_attr - 1]:
            self._of.write("%s, " % val)
        self._of.write("%s)\n" % val_encode[last_attr-1])
        self.dec_indent()
        self._of.write("\n")

    def gen_class(self, pgn_def: NMEA2000Meta, protobuf_conv: bool):

        print("Generating class for PGN", pgn_def.pgn, pgn_def.name)
        self.set_level(0)
        self._of.write('\n')
        self._of.write("class %s(%s):\n\n" % (pgn_def.class_name, self.base_class))
        if pgn_def.repeat_field_set is not None:
            # generate inner class
            self.inc_indent()
            self.gen_repeat_class(pgn_def.repeat_field_set, protobuf_conv, pgn_def.class_name)
            self.dec_indent()
            self._of.write("\n")

        # print("Decode str:", pgn_def.decode_str)
        # now start generating
        # class variables
        self.inc_indent()
        self.write_indent()
        self._of.write("_pgn = %d\n" % pgn_def.pgn)
        self.write_indent()
        self._of.write("_name = '%s'\n" % pgn_def.name)
        self.gen_class_variables(pgn_def.attributes, pgn_def.decode_str, pgn_def.last_attr)
        self.gen_enums_definition(pgn_def.enums)

        #  __init__ method
        # self.inc_indent()
        self._of.write("\n")
        self.write_indent()
        self._of.write("def __init__(self, message=None, protobuf=None):\n")
        self.inc_indent()
        self.write_indent()
        self._of.write("super().__init__(message, protobuf)\n")
        self._of.write("\n")
        # properties methods
        self.dec_indent()
        # access to class parameters
        self.gen_getter('pgn', 'int')
        self.gen_getter('name', 'str')

        self.gen_accessors_methods(pgn_def.attributes, pgn_def.enums)

        self.gen_decode_encode_methods(pgn_def.attributes, pgn_def.last_attr)

        if protobuf_conv:
            self.gen_from_protobuf(pgn_def)

        # string conversion method

        self.write_indent()
        self._of.write("def __str__(self):\n")
        self.inc_indent()
        self.write_indent()
        self._of.write("return f'PGN{self._pgn}({self._name}) [")
        for attr in pgn_def.attributes[:pgn_def.last_attr]:
            self._of.write("%s={self.%s}, " % (attr.method, attr.variable))
        self._of.write("%s={self.%s}]'\n\n" % (pgn_def.attributes[pgn_def.last_attr].method,
                                               pgn_def.attributes[pgn_def.last_attr].variable))

    def gen_getter(self, method, var_type):
        self.write("@property\n")
        self.write(f"def {method}(self) -> {var_type}:\n")
        self.inc_indent()
        self.write(f"return self._{method}\n\n")
        self.dec_indent()

    def gen_repeat_class(self, repeat_field: RepeatAttributeDef, protobuf_conv, outer_class):

        # self.inc_indent()
        self.write_indent()
        self._of.write(f"class {repeat_field.class_name}:\n")
        self.inc_indent()
        self.gen_class_variables(repeat_field.attributes, repeat_field.decode_str, repeat_field.last_attr)
        self.gen_enums_definition(repeat_field.enums)
        # gen __init__ method
        self.write_indent()
        self._of.write('def __init__(self, protobuf=None):\n')
        self.inc_indent()
        self.write_indent()
        self._of.write('if protobuf is not None:\n')
        self.inc_indent()
        self.write_indent()
        self._of.write('self.from_protobuf(protobuf)\n')
        self.dec_indent()
        self.dec_indent()
        self._of.write('\n')
        self.gen_accessors_methods(repeat_field.attributes, repeat_field.enums)
        self.gen_decode_encode_methods(repeat_field.attributes, repeat_field.last_attr)
        if protobuf_conv:
            self.gen_from_protobuf(repeat_field, outer_class)
        self.dec_indent()

    def gen_from_protobuf(self, pgn_def, base_class=None):
        self.write_indent()
        if base_class is not None:
            class_name = f'{base_class}Pb.{pgn_def.class_name}Pb'
        else:
            class_name = pgn_def.class_name + 'Pb'
        self._of.write(f'def from_protobuf(self, message: {class_name}):\n')
        self.inc_indent()
        for attr in pgn_def.attributes:
            self.write_indent()
            if isinstance(attr, RepeatAttributeDef):
                self._of.write(f'self.{attr.variable} = []\n')
                self.write_indent()
                self._of.write(f'for sub_set in message.{attr.method}:\n')
                self.inc_indent()
                self.write_indent()
                self._of.write(f'self.{attr.variable}.append(self.{attr.class_name}(protobuf=sub_set))\n')
                self.dec_indent()
            else:
                self._of.write(f'self.{attr.variable} = message.{attr.method}\n')
        self.dec_indent()
        self._of.write('\n')
        # now generate the conversion to protobuf
        self.write_indent()
        self._of.write(f'def as_protobuf(self) -> {class_name}:\n')
        self.inc_indent()
        self.write_indent()
        self._of.write(f'message = {class_name}()\n')
        for attr in pgn_def.attributes:
            self.write_indent()
            if isinstance(attr, RepeatAttributeDef):
                self._of.write(f'for sub_set in self.{attr.variable}:\n')
                self.inc_indent()
                self.write_indent()
                self._of.write(f'message.{attr.method}.append(sub_set.as_protobuf())\n')
                self.dec_indent()
            else:
                self._of.write(f'message.{attr.method} = self.{attr.variable}\n')
        self.write_indent()
        self._of.write('return message\n')
        self.dec_indent()
        self._of.write('\n')

    def gen_message_class(self, pgn_def: NMEA2000Meta, protobuf_conv):
        self.set_level(0)
        self._of.write('\n')
        self._of.write(f'class {pgn_def.msg_class_name}({self.message_base_class}, {pgn_def.class_name}):\n\n')
        self.inc_indent()
        self.write('def __init__(self, message: NMEA2000Msg = None, protobuf: nmea2000_decoded_pb = None):\n')
        self.inc_indent()
        self.write('if message is not None:\n')
        self.inc_indent()
        self.write('assert (message.pgn == self.pgn)\n')
        self.write('super().__init__(message=message)\n')
        self.write("self.decode_payload(message.payload)\n")
        self.dec_indent()
        self.write('elif protobuf is not None:\n')
        self.inc_indent()
        self.write('assert (protobuf.pgn == self.pgn)\n')
        self.write('super().__init__(protobuf=protobuf)\n')
        if protobuf_conv:
            # ok we will process de the full protobuf
            self.write('self.unpack_payload(protobuf)\n')
        self._of.write('\n')



