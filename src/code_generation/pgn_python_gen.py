# -------------------------------------------------------------------------------
# Name:        pgn_python_gen
# Purpose:     Python code generator for pgn supporting classes
#
# Author:      Laurent Carré
#
# Created:     23/11/2023
# Copyright:   (c) Laurent Carré Sterwen Technology 2021-2023
# Licence:     Eclipse Public License 2.0
# -------------------------------------------------------------------------------


import logging
import datetime
from collections import namedtuple

from nmea2000.nmea2k_pgn_definition import PGNDef
from nmea2000.nmea2k_encode_decode import BitField
from nmea2000.nmea2k_fielddefs import FIXED_LENGTH_BYTES, FIXED_LENGTH_NUMBER, VARIABLE_LENGTH_BYTES, EnumField
from utilities.global_variables import MessageServerGlobals


_logger = logging.getLogger("ShipDataServer." + __name__)

AttributeDef = namedtuple("AttributeDef", ["method", "variable", "field", "field_index",
                                           "field_type", "scale", "offset"])
BitFieldAttributeDef = namedtuple("BitFieldAttributeDef", ["method", "variable", "field",
                                            "field_index", "field_type", "nb_slots", "mask", "bit_offset"])

ClassDef = namedtuple("ClassDef", ["pgn", "manufacturer", "class_name"])

EnumDef = namedtuple("EnumDef", ["global_ref", "method", "enum_dict"])


class PythonPGNGenerator:

    level_indent = ['', '    ', '        ', '            ', '                ']
    base_class = 'NMEA2000OptimObject'

    def __init__(self, output_file):

        try:
            self._of = open(output_file, 'w')
        except IOError as err:
            _logger.error("Python code generator - error opening output file %s:%s" % (output_file, err))
            raise

        self.level = 0
        self._of.write('#   Python code generated by NMEA message router application (c) Sterwen Technology 2023\n')
        self._of.write('#   generated on %s\n' % datetime.datetime.now().strftime("%Y-%M-%d:%H:%M"))
        self._of.write('#   do not modify code\n\n\n')

        # generate imports
        self._of.write("import struct\n")
        self._of.write("\nfrom nmea2000.generated_base import %s\n" % self.base_class)

    def close(self):
        self._of.close()

    def write_indent(self):
        self._of.write(self.level_indent[self.level])

    def gen_classes(self):
        class_def_list = []
        for cls in MessageServerGlobals.pgn_definitions.generation_iter():
            class_def_list.append(self.gen_class(cls))
        # now write the class dictionary
        self._of.write("\n#####################################################################\n")
        self._of.write("#         Generated class dictionary\n")
        self._of.write("#####################################################################\n")
        self._of.write("nmea2k_generated_classes = {\n")
        self.level = 2

        def write_cls_entry(cls_def: ClassDef):
            self._of.write(f"{cls_def.pgn}: {cls_def.class_name}")

        for cls in class_def_list[:len(class_def_list)-1]:
            self.write_indent()
            write_cls_entry(cls)
            self._of.write(",\n")
        self.write_indent()
        write_cls_entry(class_def_list[len(class_def_list)-1])
        self._of.write("\n")
        self.write_indent()
        self._of.write("}\n")
        self._of.write("# end of generated file\n")

    def gen_class(self, pgn_def: PGNDef) -> ClassDef:

        print("Start generating class for PGN", pgn_def.id, pgn_def.name)
        self._of.write('\n\n')
        class_name = "Pgn%dClass" % pgn_def.id
        self._of.write("class %s(%s):\n\n" % (class_name, self.base_class))
        self.level = 1
        try:
            manufacturer = pgn_def.manufacturer_id
        except ValueError:
            manufacturer = 0
        attributes = []
        enums = []
        decode_str = "<"
        decode_index = 0
        for field in pgn_def.field_list:
            print("Field:", field.name)
            if field.decode_method == FIXED_LENGTH_NUMBER:
                decode_str += field.decode_string
                print("DEcode str:", decode_str)
            else:
                raise NotImplementedError
            current_attr = None
            if isinstance(field, BitField):
                # need to look in subfields
                for sub_field in field.sub_fields():
                    if sub_field.field().keyword is not None:
                        a_field = sub_field.field()
                        current_attr = BitFieldAttributeDef(a_field.keyword, '_%s' % a_field.keyword, a_field,
                                                               decode_index, 'int', field.nb_decode_slots,
                                                               sub_field.mask, sub_field.bit_offset)
                        attributes.append(current_attr)

            elif field.keyword is not None:
                # need to generate a local variable and cess method
                current_attr = AttributeDef(field.keyword, '_%s' % field.keyword, field, decode_index,
                                               field.python_type, field.scale, field.offset)
                attributes.append(current_attr)

            decode_index += field.nb_decode_slots

            # check enum for local generation
            if current_attr is not None:
                if issubclass(type(current_attr.field), EnumField):
                    enum_def = EnumDef(current_attr.field.global_enum, current_attr.method,
                                       current_attr.field.get_enum_dict())
                    enums.append(enum_def)

            # end attributes analysis loop

        nb_attributes = len(attributes)
        last_attr = nb_attributes - 1
        # now start generating
        # class variables
        self.write_indent()
        self._of.write("_pgn = %d\n" % pgn_def.id)
        self.write_indent()
        self._of.write("_name = '%s'\n" % pgn_def.name)
        self.write_indent()
        self._of.write("_decode_struct = struct.Struct('%s')\n" % decode_str)
        self.write_indent()
        self._of.write("__slots__ = (")
        for attr in attributes[:last_attr]:
            self._of.write("'%s', " % attr.variable)
        self._of.write("'%s')\n" % attributes[last_attr].variable)
        # enums or enum reference
        for enum in enums:
            self.write_indent()
            self._of.write(f"_{enum.method}_enum = ")
            if enum.global_ref is not None:
                self._of.write(f"MessageServerGlobals.enums.get_enum({enum.global_ref})\n")
            else:
                self._of.write("{\n")
                nb_enums = len(enum.enum_dict)
                count = 0
                self.level = 2
                for key, text in enum.enum_dict.items():
                    self.write_indent()
                    self._of.write(f"{key}: '{text}'")
                    if count < nb_enums -1:
                        self._of.write(",\n")
                    else:
                        self._of.write("\n")
                    count += 1
                self.write_indent()
                self._of.write("}\n")
        # enums



        #  __init__ method
        self.level = 1
        self._of.write("\n")
        self.write_indent()
        self._of.write("def __init__(self, message=None, protobuf=None):\n")
        self.level = 2
        self.write_indent()
        self._of.write("super().__init__(message, protobuf)\n")
        self._of.write("\n")
        # properties methods
        self.level = 1
        for attr in attributes:
            self.write_indent()
            self._of.write("@property\n")
            self.write_indent()
            self._of.write("def %s(self) -> %s:\n" % (attr.method, attr.field_type))
            self.level = 2
            self.write_indent()
            self._of.write("return self.%s\n\n" % attr.variable)
            self.level = 1
        for attr in attributes:
            self.write_indent()
            self._of.write("@%s.setter\n" % attr.method)
            self.write_indent()
            self._of.write("def %s(self, value: %s):\n" % (attr.method, attr.field_type))
            self.level = 2
            self.write_indent()
            self._of.write("self.%s = value\n\n" % attr.variable)
            self.level = 1
        #
        # enums property
        for enum in enums:
            self.write_indent()
            self._of.write("@property\n")
            self.write_indent()
            self._of.write(f"def {enum.method}_text(self) -> str:\n")
            self.level = 2
            self.write_indent()
            if enum.global_ref is not None:
                self._of.write(f"return self._{enum.method}_enum.get_enum(self._{enum.method})\n\n")
            else:
                self._of.write(f"return self._{enum.method}_enum.get(self._{enum.method}, '{enum.method} key error')\n\n")
            self.level = 1
        #
        # decode method =================================================
        #
        self.write_indent()
        self._of.write("def decode_payload(self, payload):\n")
        self.level = 2
        self.write_indent()
        self._of.write("val = self._decode_struct.unpack(payload)\n")
        for attr in attributes:
            self.write_indent()
            print(attr.__class__.__name__)
            if isinstance(attr, AttributeDef):
                self._of.write("self.%s = " % attr.variable)
                if attr.scale is not None:
                    self._of.write("val[%d] * %s" % (attr.field_index, str(attr.scale)))
                elif attr.field_type == "float":
                    self._of.write("float(val[%d])" % attr.field_index)
                else:
                    self._of.write("val[%d]" % attr.field_index)
                if attr.offset is not None:
                    self._of.write(" + %s" % str(attr.offset))
            elif isinstance(attr, BitFieldAttributeDef):
                self._of.write(f"word = val[{attr.field_index}]")
                if attr.nb_slots == 2:
                    self._of.write(f" + val[{attr.field_index} + 1] << 16")
                self._of.write("\n")
                self.write_indent()
                self._of.write(f"self.{attr.variable} = (word >> {attr.bit_offset}) & {attr.mask}")
            self._of.write("\n")
        self.level = 1
        self._of.write("\n")
        # encode method
        self.write_indent()
        self._of.write("def encode_payload(self):\n")
        self.level = 2

        val_encode = []
        numvi = 0
        # first need to convert in int if float
        for attr in attributes:
            if attr.field_type == "float":
                vi = "v%d" % numvi
                numvi += 1
                val_encode.append(vi)
                self.write_indent()
                self._of.write("%s = int(" % vi)
                if attr.offset is not None:
                    self._of.write("(self.%s - %s)" % (attr.variable, attr.offset))
                else:
                    self._of.write("self.%s" % attr.variable)
                if attr.scale is not None:
                    self._of.write(" / %s" % attr.scale)
                self._of.write(")\n")
            else:
                val_encode.append("self.%s" % attr.variable)
        self.write_indent()
        self._of.write("return self._decode_struct.pack(")
        for val in val_encode[:last_attr]:
            self._of.write("%s, " % val)
        self._of.write("%s)\n\n" % val_encode[last_attr])
        # string conversion method
        self.level = 1
        self.write_indent()
        self._of.write("def __str__(self):\n")
        self.level = 2
        self.write_indent()
        self._of.write("return f'PGN{self._pgn}({self._name}) [")
        for attr in attributes[:last_attr]:
            self._of.write("%s={self.%s}, " % (attr.method, attr.variable))
        self._of.write("%s={self.%s}]'\n\n" % (attributes[last_attr].method, attributes[last_attr].variable))

        return ClassDef(pgn_def.id, manufacturer, class_name)













